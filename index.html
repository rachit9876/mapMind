<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Designer</title>
    <meta name="description" content="A simple, elegant mind map designer.">
    <meta name="color-scheme" content="light dark">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }

        /* Design tokens via CSS variables (light/dark) */
        :root {
            --bg: #f6f7fb;
            --dot: rgba(17, 24, 39, 0.08); /* gray-900 @ 8% */
            --line: #9ca3af; /* gray-400 */
            --node-fill: #ffffff;
            --node-border: #e5e7eb; /* gray-200 */
            --node-text: #111827; /* gray-900 */
            --selected-border: #4f46e5; /* indigo-600 */
            --multi-border: #10b981; /* emerald-500 */
            --drag-border: #a5b4fc; /* indigo-300 */
            --shadow: rgba(0, 0, 0, 0.12);
        }

        html.dark {
            --bg: #0b1220;
            --dot: rgba(255, 255, 255, 0.12);
            --line: #4b5563; /* gray-600 */
            --node-fill: #0f172a; /* slate-900 */
            --node-border: #1f2937; /* gray-800 */
            --node-text: #e5e7eb; /* gray-200 */
            --selected-border: #6366f1; /* indigo-500 */
            --multi-border: #34d399; /* emerald-400 */
            --drag-border: #818cf8; /* indigo-400 */
            --shadow: rgba(0, 0, 0, 0.5);
        }

        /* Custom dotted background for the canvas */
        .dot-background {
            background-color: var(--bg);
            background-image: radial-gradient(var(--dot) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #mindMapCanvas {
            cursor: grab;
        }

        #mindMapCanvas:active {
            cursor: grabbing;
        }

        /* Styles for the custom context menu */
        #context-menu {
            position: absolute;
            z-index: 1000;
            display: none;
            background-color: #fff;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            padding: 0.5rem;
            min-width: 150px;
        }

        #context-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #context-menu li {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #4a5568; /* text-gray-700 */
            transition: background-color 0.2s;
            border-radius: 0.5rem; /* rounded-lg */
        }

        #context-menu li:hover {
            background-color: #f7fafc; /* bg-gray-50 */
        }

        #context-menu li.disabled {
            color: #cbd5e0; /* text-gray-400 */
            cursor: not-allowed;
        }

        /* In-line text input for renaming */
        #inline-rename-input {
            position: absolute;
            z-index: 500;
            display: none;
            background: #fff;
            border: 2px solid #4c51bf; /* indigo-600 */
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            font: 16px 'Inter', sans-serif;
            color: #1f2937;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <!-- Top Header -->
    <header class="bg-white/80 dark:bg-slate-900/70 backdrop-blur p-3 md:p-4 shadow-sm border-b border-gray-200 dark:border-slate-800 flex justify-between items-center z-10">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded-md bg-indigo-600 flex items-center justify-center shadow-sm">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" class="w-5 h-5">
                    <path d="M12 2a1 1 0 0 1 1 1v2.06a7.002 7.002 0 0 1 6.94 6.167l2.06.275a1 1 0 1 1-.26 1.982l-2.06-.275A7.002 7.002 0 0 1 13 20.94V23a1 1 0 1 1-2 0v-2.06a7.002 7.002 0 0 1-6.94-6.167l-2.06-.275a1 1 0 0 1 .26-1.982l2.06.275A7.002 7.002 0 0 1 11 5.06V3a1 1 0 0 1 1-1Zm0 6a5 5 0 1 0 0 10 5 5 0 0 0 0-10Z"/>
                </svg>
            </div>
            <div>
                <h1 class="text-lg md:text-2xl font-semibold text-gray-900 dark:text-gray-100 leading-tight">Mind Map Designer</h1>
                <p class="hidden md:block text-xs text-gray-500 dark:text-gray-400">Create, connect, and organize ideas with ease</p>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <button id="zoomOutBtn" class="inline-flex items-center justify-center w-9 h-9 rounded-lg bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 shadow-sm transition-colors" title="Zoom out (Ctrl + -)">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-700 dark:text-gray-200"><path fill-rule="evenodd" d="M10 3.75a6.25 6.25 0 1 1 0 12.5 6.25 6.25 0 0 1 0-12.5Zm0 1.5a4.75 4.75 0 1 0 0 9.5 4.75 4.75 0 0 0 0-9.5ZM21 20.25a.75.75 0 0 1-1.06 0l-4.22-4.22a8.5 8.5 0 1 1 1.06-1.06l4.22 4.22a.75.75 0 0 1 0 1.06ZM6.75 10a.75.75 0 0 1 .75-.75h5a.75.75 0 0 1 0 1.5h-5A.75.75 0 0 1 6.75 10Z" clip-rule="evenodd"/></svg>
            </button>
            
            <div id="zoomIndicator" class="px-3 py-2 text-xs font-medium text-gray-700 dark:text-gray-200 bg-gray-50 dark:bg-slate-700 border border-gray-200 dark:border-slate-600 rounded-lg">100%</div>
            
            <button id="zoomInBtn" class="inline-flex items-center justify-center w-9 h-9 rounded-lg bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 shadow-sm transition-colors" title="Zoom in (Ctrl + +)">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-700 dark:text-gray-200"><path fill-rule="evenodd" d="M10 3.75a6.25 6.25 0 1 1 0 12.5 6.25 6.25 0 0 1 0-12.5Zm0 1.5a4.75 4.75 0 1 0 0 9.5 4.75 4.75 0 0 0 0-9.5ZM21 20.25a.75.75 0 0 1-1.06 0l-4.22-4.22a8.5 8.5 0 1 1 1.06-1.06l4.22 4.22a.75.75 0 0 1 0 1.06ZM10.75 6.5a.75.75 0 0 0-1.5 0V9.25H6.5a.75.75 0 0 0 0 1.5h2.75V13.5a.75.75 0 0 0 1.5 0V10.75H13.5a.75.75 0 0 0 0-1.5h-2.75V6.5Z" clip-rule="evenodd"/></svg>
            </button>

            <button id="fitViewBtn" class="inline-flex items-center gap-2 bg-gray-100 dark:bg-slate-800 hover:bg-white dark:hover:bg-slate-700 text-gray-800 dark:text-gray-100 font-medium py-2 px-3 md:px-4 rounded-lg border border-gray-200 dark:border-slate-700 shadow-sm transition-colors" title="Fit to view">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M4.5 4.5h6a.75.75 0 0 0 0-1.5h-6A2.25 2.25 0 0 0 2.25 5.25v6a.75.75 0 0 0 1.5 0v-6A.75.75 0 0 1 4.5 4.5Zm9 0h6a.75.75 0 0 1 .75.75v6a.75.75 0 0 0 1.5 0v-6A2.25 2.25 0 0 0 19.5 3h-6a.75.75 0 0 0 0 1.5Zm7.5 9a.75.75 0 0 0-1.5 0v6a.75.75 0 0 1-.75.75h-6a.75.75 0 0 0 0 1.5h6A2.25 2.25 0 0 0 21.75 19.5v-6Zm-18 6v-6a.75.75 0 0 0-1.5 0v6A2.25 2.25 0 0 0 4.5 21.75h6a.75.75 0 0 0 0-1.5h-6a.75.75 0 0 1-.75-.75Z"/></svg>
                <span class="hidden md:inline">Fit</span>
            </button>

            <button id="resetPositionBtn" class="inline-flex items-center gap-2 bg-gray-100 dark:bg-slate-800 hover:bg-white dark:hover:bg-slate-700 text-gray-800 dark:text-gray-100 font-medium py-2 px-3 md:px-4 rounded-lg border border-gray-200 dark:border-slate-700 shadow-sm transition-colors" title="Center on first node">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M12 3.75a.75.75 0 0 1 .75.75v2.31a6.19 6.19 0 0 1 4.44 4.44h2.31a.75.75 0 0 1 0 1.5H17.19a6.19 6.19 0 0 1-4.44 4.44v2.31a.75.75 0 0 1-1.5 0v-2.31a6.19 6.19 0 0 1-4.44-4.44H4.5a.75.75 0 0 1 0-1.5h2.31A6.19 6.19 0 0 1 10.5 6.81V4.5a.75.75 0 0 1 .75-.75Z"/></svg>
                <span class="hidden md:inline">Center</span>
            </button>

            <button id="createNodeBtn" class="inline-flex items-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-3 md:px-4 rounded-lg border border-indigo-600 dark:border-indigo-600 shadow-sm transition-colors" title="Create node (Right-click anywhere too)">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M12 4.5a.75.75 0 0 1 .75.75v6h6a.75.75 0 0 1 0 1.5h-6v6a.75.75 0 0 1-1.5 0v-6h-6a.75.75 0 0 1 0-1.5h6v-6A.75.75 0 0 1 12 4.5Z"/></svg>
                <span class="hidden md:inline">New</span>
            </button>

            <button id="curvedLinesToggle" class="inline-flex items-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-3 md:px-4 rounded-lg border border-indigo-600 shadow-sm transition-colors" title="Toggle curved lines">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M3 12c0-.75.75-1.5 1.5-1.5s1.5.75 1.5 1.5-.75 1.5-1.5 1.5S3 12.75 3 12zm6-3c0-.75.75-1.5 1.5-1.5s1.5.75 1.5 1.5-.75 1.5-1.5 1.5S9 9.75 9 9zm6 6c0-.75.75-1.5 1.5-1.5s1.5.75 1.5 1.5-.75 1.5-1.5 1.5-1.5-.75-1.5-1.5z"/></svg>
                <span class="hidden md:inline">Curves</span>
            </button>

            <button id="themeToggle" class="inline-flex items-center justify-center w-9 h-9 rounded-lg bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 shadow-sm transition-colors" title="Toggle theme">
                <svg id="iconSun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-700 dark:text-gray-200"><path d="M12 18.25a6.25 6.25 0 1 0 0-12.5 6.25 6.25 0 0 0 0 12.5ZM12 1.5a.75.75 0 0 1 .75.75v2a.75.75 0 1 1-1.5 0v-2A.75.75 0 0 1 12 1.5Zm0 17.5a.75.75 0 0 1 .75.75v2a.75.75 0 1 1-1.5 0v-2a.75.75 0 0 1 .75-.75ZM22.5 12a.75.75 0 0 1-.75.75h-2a.75.75 0 1 1 0-1.5h2a.75.75 0 0 1 .75.75ZM5.25 12a.75.75 0 0 1-.75.75h-2a.75.75 0 1 1 0-1.5h2a.75.75 0 0 1 .75.75Zm13.01 7.04a.75.75 0 0 1-1.06 0l-1.42-1.42a.75.75 0 1 1 1.06-1.06l1.42 1.42a.75.75 0 0 1 0 1.06Zm-10.5-10.5a.75.75 0 0 1-1.06 0L5.28 7.12a.75.75 0 1 1 1.06-1.06l1.42 1.42a.75.75 0 0 1 0 1.06Zm10.5-6.56a.75.75 0 0 1 0 1.06l-1.42 1.42a.75.75 0 0 1-1.06-1.06l1.42-1.42a.75.75 0 0 1 1.06 0Zm-10.5 10.5a.75.75 0 0 1 0 1.06L6.79 16.0a.75.75 0 1 1-1.06-1.06l1.42-1.42a.75.75 0 0 1 1.06 0Z"/></svg>
            </button>

            <button id="downloadBtn" class="inline-flex items-center justify-center w-9 h-9 rounded-lg bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 shadow-sm transition-colors" title="Download">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-700 dark:text-gray-200"><path d="M12 1.5a.75.75 0 0 1 .75.75v7.94l2.47-2.47a.75.75 0 1 1 1.06 1.06l-3.75 3.75a.75.75 0 0 1-1.06 0L7.72 8.78a.75.75 0 0 1 1.06-1.06L11.25 10.19V2.25A.75.75 0 0 1 12 1.5Zm-7.5 9a.75.75 0 0 1 .75.75v6a.75.75 0 0 0 .75.75h12a.75.75 0 0 0 .75-.75v-6a.75.75 0 0 1 1.5 0v6A2.25 2.25 0 0 1 18 21.75H6A2.25 2.25 0 0 1 3.75 18v-6a.75.75 0 0 1 .75-.75Z"/></svg>
            </button>

            <button id="openBtn" class="inline-flex items-center justify-center w-9 h-9 rounded-lg bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 shadow-sm transition-colors" title="Open">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-700 dark:text-gray-200"><path d="M19.5 21a3 3 0 0 0 3-3v-4.5a3 3 0 0 0-3-3h-15a3 3 0 0 0-3 3V18a3 3 0 0 0 3 3h15ZM1.5 10.146V6a3 3 0 0 1 3-3h5.379a2.25 2.25 0 0 1 1.59.659l2.122 2.121c.14.141.331.22.53.22H19.5a3 3 0 0 1 3 3v1.146A4.483 4.483 0 0 0 19.5 9h-15a4.483 4.483 0 0 0-3 1.146Z"/></svg>
            </button>

            <button id="helpBtn" class="inline-flex items-center justify-center w-9 h-9 rounded-lg bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 hover:bg-white dark:hover:bg-slate-700 shadow-sm transition-colors" title="Shortcuts">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-700 dark:text-gray-200"><path d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75S6.615 21.75 12 21.75s9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-.007 14.997a1.125 1.125 0 1 1 0 2.25 1.125 1.125 0 0 1 0-2.25ZM12 5.25a4.5 4.5 0 0 1 3.642 7.07c-.532.753-1.22 1.245-1.777 1.648-.2.145-.384.279-.53.402-.148.125-.256.23-.321.35a.75.75 0 1 1-1.328-.676c.19-.373.485-.62.74-.824.167-.133.35-.263.557-.415.497-.361 1.03-.75 1.368-1.226A3 3 0 1 0 9 9.75a.75.75 0 0 1-1.5 0 4.5 4.5 0 0 1 4.5-4.5Z"/></svg>
            </button>
        </div>
    </header>

    <!-- Canvas Container -->
    <main class="flex-1 dot-background">
        <canvas id="mindMapCanvas" class="w-full h-full"></canvas>
    </main>
    
    <!-- Inline text input for renaming -->
    <input type="text" id="inline-rename-input">
    
    <!-- Hidden file input for opening files -->
    <input type="file" id="fileInput" accept=".rxt" style="display: none;">

    <!-- Custom Right-Click Menu -->
    <div id="context-menu" class="hidden">
        <ul>
            <li id="menu-add-branch" class="disabled">Add Branch</li>
            <li id="menu-create">Create New Node</li>
            <li id="menu-rename" class="disabled">Rename Node</li>
            <li id="menu-delete" class="disabled">Delete Element</li>
            <li id="menu-delete-connection" class="disabled">Delete Connection</li>
        </ul>
    </div>

    <!-- Help modal -->
    <div id="helpModal" class="fixed inset-0 hidden items-center justify-center">
        <div class="absolute inset-0 bg-black/40"></div>
        <div class="relative z-10 w-[90%] max-w-lg bg-white dark:bg-slate-900 border border-gray-200 dark:border-slate-800 rounded-xl shadow-xl p-5">
            <div class="flex items-center justify-between mb-3">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Shortcuts</h2>
                <button id="helpCloseBtn" class="w-8 h-8 inline-flex items-center justify-center rounded-md hover:bg-gray-100 dark:hover:bg-slate-800" title="Close">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-600 dark:text-gray-300"><path fill-rule="evenodd" d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"/></svg>
                </button>
            </div>
            <ul class="text-sm text-gray-700 dark:text-gray-300 space-y-2">
                <li><span class="font-medium">Ctrl/Cmd + Click</span>: multi-select nodes</li>
                <li><span class="font-medium">Enter</span>: connect selected nodes in order</li>
                <li><span class="font-medium">Double-click node</span>: rename inline</li>
                <li><span class="font-medium">Mouse wheel</span>: zoom in/out</li>
                <li><span class="font-medium">Drag empty space</span>: pan</li>
                <li><span class="font-medium">Right-click</span>: context menu</li>
            </ul>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Get references to all DOM elements
            const canvas = document.getElementById('mindMapCanvas');
            const ctx = canvas.getContext('2d');
            const createNodeBtn = document.getElementById('createNodeBtn');
            const resetPositionBtn = document.getElementById('resetPositionBtn');
            const curvedLinesToggle = document.getElementById('curvedLinesToggle');
            let curvedLinesEnabled = true;
            const themeToggle = document.getElementById('themeToggle');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomIndicator = document.getElementById('zoomIndicator');
            const fitViewBtn = document.getElementById('fitViewBtn');
            const contextMenu = document.getElementById('context-menu');
            const menuCreateBtn = document.getElementById('menu-create');
            const menuAddBranchBtn = document.getElementById('menu-add-branch');
            const menuRenameBtn = document.getElementById('menu-rename');
            const menuDeleteBtn = document.getElementById('menu-delete');
            const menuDeleteConnectionBtn = document.getElementById('menu-delete-connection');
            const inlineRenameInput = document.getElementById('inline-rename-input');
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const helpCloseBtn = document.getElementById('helpCloseBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const openBtn = document.getElementById('openBtn');
            const fileInput = document.getElementById('fileInput');

            // --- State Management ---
            let nodes = [];
            let selectedNodeId = null;
            let draggedNodeId = null;
            let lastMouseX, lastMouseY;
            let nextNodeId = 1;
            let zoomScale = 1;
            let panX = 0, panY = 0;
            let editingNodeId = null;
            let textSelected = false;
            let cursorPosition = 0;
            let multiSelectedNodes = [];
            let selectedConnectionId = null;

            // --- Canvas and Drawing Logic ---

            // Function to resize canvas to fill the window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - document.querySelector('header').offsetHeight;
                draw();
            }

            // Function to draw the entire mind map
            function draw() {
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update background dot size based on zoom
                const dotSize = 20 * zoomScale;
                canvas.parentElement.style.backgroundSize = `${dotSize}px ${dotSize}px`;
                canvas.parentElement.style.backgroundPosition = `${panX % dotSize}px ${panY % dotSize}px`;
                
                // Read theme colors
                const styles = getComputedStyle(document.documentElement);
                const colorLine = styles.getPropertyValue('--line').trim();
                const colorNodeFill = styles.getPropertyValue('--node-fill').trim();
                const colorNodeText = styles.getPropertyValue('--node-text').trim();
                const colorSelected = styles.getPropertyValue('--selected-border').trim();
                const colorMulti = styles.getPropertyValue('--multi-border').trim();
                const colorDrag = styles.getPropertyValue('--drag-border').trim();
                const nodeShadow = styles.getPropertyValue('--shadow').trim();

                // Apply zoom and pan transformation
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoomScale, zoomScale);

                // Draw branches (lines) first
                // Ensure consistent font before measuring/drawing text
                ctx.font = '16px "Inter", sans-serif';

                for (const node of nodes) {
                    if (node.parent !== null) {
                        const parentNode = nodes.find(n => n.id === node.parent);
                        if (parentNode) {
                            // Calculate the start and end points at the center of the nodes
                            const startX = parentNode.x + parentNode.width / 2;
                            const startY = parentNode.y + parentNode.height / 2;
                            const endX = node.x + node.width / 2;
                            const endY = node.y + node.height / 2;

                            ctx.beginPath();
                            ctx.moveTo(startX, startY);

                            if (curvedLinesEnabled) {
                                // Calculate a dynamic control offset for a smoother S-curve
                                // Increased the multiplier from 0.3 to 0.6 for a more pronounced curve.
                                const dx = endX - startX;
                                const dy = endY - startY;
                                const controlOffset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.6;

                                // Draw a gentle S-curve using a cubic Bézier curve
                                // The control points create a smooth "bend" in the line.
                                ctx.bezierCurveTo(
                                    startX + controlOffset, startY,
                                    endX - controlOffset, endY,
                                    endX, endY
                                );
                            } else {
                                // Draw a straight line
                                ctx.lineTo(endX, endY);
                            }

                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.strokeStyle = colorLine;
                            ctx.stroke();
                        }
                    }
                }

                // Draw nodes
                for (const node of nodes) {
                    // Node styles
                    const isSelected = (node.id === selectedNodeId);
                    const isMultiSelected = multiSelectedNodes.includes(node.id);
                    const isDragged = (node.id === draggedNodeId);
            ctx.fillStyle = colorNodeFill;
            ctx.strokeStyle = isSelected ? colorSelected : (isMultiSelected ? colorMulti : (isDragged ? colorDrag : styles.getPropertyValue('--node-border').trim()));
            ctx.lineWidth = isSelected ? 3 : (isMultiSelected ? 2.5 : (isDragged ? 2.5 : 1.5));
            ctx.shadowColor = nodeShadow;
            ctx.shadowBlur = 8;
            ctx.shadowOffsetY = 2;
                    
                    // Draw node rectangle
                    const padding = 15;
                    // Measure text to determine node dimensions (font set above)
                    const lines = node.text.split('\n');
                    const maxLineWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                    const rectWidth = Math.max(maxLineWidth + padding * 2, 96);
                    const rectHeight = Math.max(lines.length * 20 + padding, 40);
                    
                    // Draw a rounded rectangle for the node
                    ctx.beginPath();
                    const radius = 10;
                    ctx.moveTo(node.x + radius, node.y);
                    ctx.lineTo(node.x + rectWidth - radius, node.y);
                    ctx.arc(node.x + rectWidth - radius, node.y + radius, radius, Math.PI * 1.5, Math.PI * 2);
                    ctx.lineTo(node.x + rectWidth, node.y + rectHeight - radius);
                    ctx.arc(node.x + rectWidth - radius, node.y + rectHeight - radius, radius, 0, Math.PI * 0.5);
                    ctx.lineTo(node.x + radius, node.y + rectHeight);
                    ctx.arc(node.x + radius, node.y + rectHeight - radius, radius, Math.PI * 0.5, Math.PI);
                    ctx.lineTo(node.x, node.y + radius);
                    ctx.arc(node.x + radius, node.y + radius, radius, Math.PI, Math.PI * 1.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw text inside the node
                    ctx.fillStyle = colorNodeText;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const lineHeight = 20;
                    const totalTextHeight = lines.length * lineHeight;
                    const startY = node.y + rectHeight / 2 - totalTextHeight / 2 + lineHeight / 2;
                    
                    // Show cursor for editing node
                    if (node.id === editingNodeId) {
                        if (textSelected) {
                            // Draw pink selection background
                            ctx.fillStyle = '#ffc0cb';
                            ctx.fillRect(node.x + 5, node.y + 5, rectWidth - 10, rectHeight - 10);
                            ctx.fillStyle = colorNodeText;
                        }
                        
                        if (textSelected) {
                            // Draw multiline text
                            lines.forEach((line, i) => {
                                ctx.fillText(line, node.x + rectWidth / 2, startY + i * lineHeight);
                            });
                        } else {
                            // Draw text with cursor
                            const beforeCursor = node.text.substring(0, cursorPosition);
                            const beforeLines = beforeCursor.split('\n');
                            const currentLineIndex = beforeLines.length - 1;
                            const currentLineText = beforeLines[currentLineIndex];
                            
                            // Draw all lines
                            lines.forEach((line, i) => {
                                ctx.fillText(line, node.x + rectWidth / 2, startY + i * lineHeight);
                            });
                            
                            // Draw blinking cursor
                            if (Math.floor(Date.now() / 400) % 2) {
                                const cursorLineY = startY + currentLineIndex * lineHeight;
                                const beforeWidth = ctx.measureText(currentLineText).width;
                                const cursorX = node.x + rectWidth / 2 - ctx.measureText(lines[currentLineIndex]).width / 2 + beforeWidth;
                                ctx.fillRect(cursorX, cursorLineY - 10, 2, 20);
                            }
                        }
                    } else {
                        // Draw multiline text for non-editing nodes
                        lines.forEach((line, i) => {
                            ctx.fillText(line, node.x + rectWidth / 2, startY + i * lineHeight);
                        });
                    }
                    
                    // Update node dimensions for hit testing
                    node.width = rectWidth;
                    node.height = rectHeight;
                    // Reset shadow for next operations
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                }
                
                // Restore transformation
                ctx.restore();

                // Update zoom indicator
                if (zoomIndicator) {
                    zoomIndicator.textContent = `${Math.round(zoomScale * 100)}%`;
                }
            }

            // Hit test to see if a click is inside a node
            function isInsideNode(x, y) {
                // Adjust coordinates for zoom and pan
                const adjustedX = (x - panX) / zoomScale;
                const adjustedY = (y - panY) / zoomScale;
                
                for (const node of nodes) {
                    // Hit test logic to check if a point (x, y) is inside the node's bounds
                    if (adjustedX > node.x && adjustedX < node.x + node.width &&
                        adjustedY > node.y && adjustedY < node.y + node.height) {
                        return node.id;
                    }
                }
                return null;
            }

            // Hit test to see if a click is on a connection line
            function isOnConnection(x, y) {
                // Convert screen coords to canvas (world) coords
                const adjustedX = (x - panX) / zoomScale;
                const adjustedY = (y - panY) / zoomScale;
                // Keep hit tolerance roughly constant in screen space
                const tolerance = 8 / zoomScale;
                const segDist = (px, py, x1, y1, x2, y2) => {
                    const A = px - x1;
                    const B = py - y1;
                    const C = x2 - x1;
                    const D = y2 - y1;
                    const dot = A * C + B * D;
                    const lenSq = C * C + D * D;
                    let t = lenSq !== 0 ? dot / lenSq : -1;
                    t = Math.max(0, Math.min(1, t));
                    const xx = x1 + t * C;
                    const yy = y1 + t * D;
                    const dx = px - xx;
                    const dy = py - yy;
                    return Math.hypot(dx, dy);
                };
                
                for (const node of nodes) {
                    if (node.parent !== null) {
                        const parentNode = nodes.find(n => n.id === node.parent);
                        if (parentNode) {
                            const startX = parentNode.x + parentNode.width / 2;
                            const startY = parentNode.y + parentNode.height / 2;
                            const endX = node.x + node.width / 2;
                            const endY = node.y + node.height / 2;
                            if (curvedLinesEnabled) {
                                // Approximate the cubic Bezier curve with small segments and test distance
                                const dx = endX - startX;
                                const dy = endY - startY;
                                const controlOffset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.6;
                                const c1x = startX + controlOffset;
                                const c1y = startY;
                                const c2x = endX - controlOffset;
                                const c2y = endY;
                                const steps = 20;
                                let prevX = startX;
                                let prevY = startY;
                                for (let i = 1; i <= steps; i++) {
                                    const t = i / steps;
                                    // Cubic Bezier formula
                                    const mt = 1 - t;
                                    const bx = mt*mt*mt*startX + 3*mt*mt*t*c1x + 3*mt*t*t*c2x + t*t*t*endX;
                                    const by = mt*mt*mt*startY + 3*mt*mt*t*c1y + 3*mt*t*t*c2y + t*t*t*endY;
                                    if (segDist(adjustedX, adjustedY, prevX, prevY, bx, by) <= tolerance) {
                                        return { parentId: node.parent, childId: node.id };
                                    }
                                    prevX = bx;
                                    prevY = by;
                                }
                            } else {
                                if (segDist(adjustedX, adjustedY, startX, startY, endX, endY) <= tolerance) {
                                    return { parentId: node.parent, childId: node.id };
                                }
                            }
                        }
                    }
                }
                return null;
            }

            // Clean up connection inconsistencies
            function cleanupConnections() {
                // Remove duplicate children and fix parent-child mismatches
                for (const node of nodes) {
                    // Remove duplicate children
                    node.children = [...new Set(node.children)];
                    
                    // Ensure all children exist and have this node as parent
                    node.children = node.children.filter(childId => {
                        const child = nodes.find(n => n.id === childId);
                        if (!child) return false; // Child node doesn't exist
                        if (child.parent !== node.id) {
                            // Fix the parent reference
                            child.parent = node.id;
                        }
                        return true;
                    });
                    
                    // If node has a parent, ensure parent exists and has this node as child
                    if (node.parent !== null) {
                        const parent = nodes.find(n => n.id === node.parent);
                        if (parent) {
                            if (!parent.children.includes(node.id)) {
                                parent.children.push(node.id);
                            }
                        } else {
                            // Parent doesn't exist, remove the reference
                            node.parent = null;
                        }
                    }
                }
            }

            // --- Node Operations ---

            // Creates a new node and adds it to the mind map
            function createNode(x, y, text = 'New Node', parentId = null, autoEdit = false) {
                // Calculate initial dimensions
                ctx.font = '16px "Inter", sans-serif';
                const textWidth = ctx.measureText(text).width;
                const padding = 15;
                
                const newNode = {
                    id: nextNodeId++,
                    text: text,
                    x: x,
                    y: y,
                    parent: parentId,
                    children: [],
                    width: textWidth + padding * 2,
                    height: 40
                };
                nodes.push(newNode);

                if (parentId !== null) {
                    const parentNode = nodes.find(n => n.id === parentId);
                    if (parentNode) {
                        parentNode.children.push(newNode.id);
                    }
                }
                
                if (autoEdit) {
                    editingNodeId = newNode.id;
                    selectedNodeId = newNode.id;
                    textSelected = false;
                    cursorPosition = 0;
                }
                
                draw();
                return newNode.id;
            }

            // Deletes a node and all its children
            function deleteNode(nodeId) {
                const nodeToDelete = nodes.find(n => n.id === nodeId);
                if (!nodeToDelete) return;

                const nodesToDelete = [nodeId];
                let queue = [...nodeToDelete.children];

                while (queue.length > 0) {
                    const childId = queue.shift();
                    nodesToDelete.push(childId);
                    const childNode = nodes.find(n => n.id === childId);
                    if (childNode) {
                        queue = queue.concat(childNode.children);
                    }
                }

                // Filter out all nodes to be deleted
                nodes = nodes.filter(n => !nodesToDelete.includes(n.id));

                // Remove from parent's children array
                if (nodeToDelete.parent !== null) {
                    const parentNode = nodes.find(n => n.id === nodeToDelete.parent);
                    if (parentNode) {
                        parentNode.children = parentNode.children.filter(childId => childId !== nodeId);
                    }
                }

                draw();
            }

            // Deletes a connection between two nodes
            function deleteConnection(parentId, childId) {
                const parentNode = nodes.find(n => n.id === parentId);
                const childNode = nodes.find(n => n.id === childId);
                
                if (parentNode && childNode) {
                    // Remove child from parent's children array
                    parentNode.children = parentNode.children.filter(id => id !== childId);
                    // Remove parent reference from child
                    childNode.parent = null;
                    draw();
                }
            }

            // Renames a node
            function renameNode(nodeId, newText) {
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                    node.text = newText;
                    draw();
                }
            }
            
            // --- Event Listeners ---
            
            // Note: Right-click context menu is handled on the canvas element below; do not block it globally
            
            // Initialize the canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Continuous redraw for blinking cursor
            setInterval(() => {
                if (editingNodeId !== null && !textSelected) {
                    draw();
                }
            }, 200);
            
            // Reset position to focus on first node
            resetPositionBtn.addEventListener('click', () => {
                if (nodes.length > 0) {
                    const firstNode = nodes[0];
                    panX = canvas.width / 2 - (firstNode.x + firstNode.width / 2) * zoomScale;
                    panY = canvas.height / 2 - (firstNode.y + firstNode.height / 2) * zoomScale;
                    draw();
                }
            });

            // Create initial node when the button is clicked
            createNodeBtn.addEventListener('click', () => {
                // Place the first node in the center of the canvas
                if (nodes.length === 0) {
                    createNode(canvas.width / 2 - 50, canvas.height / 2 - 20, "Main Idea");
                } else {
                    // For subsequent nodes, create them near the top-left
                    createNode(50, 50);
                }
            });

            // Handle scroll wheel for zooming
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.1, Math.min(3, zoomScale * zoomFactor));
                
                // Adjust pan to zoom towards mouse position
                panX = mouseX - (mouseX - panX) * (newZoom / zoomScale);
                panY = mouseY - (mouseY - panY) * (newZoom / zoomScale);
                
                zoomScale = newZoom;
                draw();
            });

            // Zoom buttons
            if (zoomInBtn && zoomOutBtn) {
                zoomInBtn.addEventListener('click', () => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = rect.width / 2;
                    const mouseY = rect.height / 2;
                    const newZoom = Math.min(3, zoomScale * 1.1);
                    panX = mouseX - (mouseX - panX) * (newZoom / zoomScale);
                    panY = mouseY - (mouseY - panY) * (newZoom / zoomScale);
                    zoomScale = newZoom;
                    draw();
                });
                zoomOutBtn.addEventListener('click', () => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = rect.width / 2;
                    const mouseY = rect.height / 2;
                    const newZoom = Math.max(0.1, zoomScale / 1.1);
                    panX = mouseX - (mouseX - panX) * (newZoom / zoomScale);
                    panY = mouseY - (mouseY - panY) * (newZoom / zoomScale);
                    zoomScale = newZoom;
                    draw();
                });
            }

            // Handle mouse down event on canvas for dragging
            canvas.addEventListener('mousedown', (e) => {
                // Only allow left-click dragging
                if (e.button !== 0) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const clickedNodeId = isInsideNode(mouseX, mouseY);
                
                // Auto-save if clicking away from editing node
                if (editingNodeId !== null && clickedNodeId !== editingNodeId) {
                    editingNodeId = null;
                    textSelected = false;
                }
                
                // Handle Ctrl/Meta + click for multi-selection
                if ((e.ctrlKey || e.metaKey) && clickedNodeId !== null) {
                    // If there's a selectedNodeId that's not in multiSelectedNodes, add it first
                    if (selectedNodeId !== null && !multiSelectedNodes.includes(selectedNodeId)) {
                        multiSelectedNodes.push(selectedNodeId);
                    }
                    
                    if (multiSelectedNodes.includes(clickedNodeId)) {
                        // Remove from selection
                        multiSelectedNodes = multiSelectedNodes.filter(id => id !== clickedNodeId);
                    } else {
                        // Add to selection
                        multiSelectedNodes.push(clickedNodeId);
                    }
                    selectedNodeId = clickedNodeId;
                    draw();
                    return; // Don't start dragging when Ctrl+clicking
                }
                
                // Set selected node on single click, clear if clicking empty space
                if (clickedNodeId !== null) {
                    selectedNodeId = clickedNodeId;
                    multiSelectedNodes = []; // Clear multi-selection on normal click
                } else {
                    selectedNodeId = null;
                    multiSelectedNodes = [];
                }
                
                draggedNodeId = clickedNodeId;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                contextMenu.style.display = 'none'; // Hide menu on drag start
                canvas.style.cursor = 'grabbing';
                draw();
            });

            // Handle mouse move event for dragging and cursor updates
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Update cursor based on hover state when not dragging
                if (lastMouseX === undefined) {
                    const hoveredNodeId = isInsideNode(mouseX, mouseY);
                    canvas.style.cursor = hoveredNodeId !== null ? 'default' : 'grab';
                }
                
                if (lastMouseX !== undefined && lastMouseY !== undefined) {
                    if (draggedNodeId !== null) {
                        // Move the selected node
                        const nodeToDrag = nodes.find(n => n.id === draggedNodeId);
                        if (nodeToDrag) {
                            nodeToDrag.x += (mouseX - lastMouseX) / zoomScale;
                            nodeToDrag.y += (mouseY - lastMouseY) / zoomScale;
                        }
                    } else {
                        // Pan the canvas
                        panX += mouseX - lastMouseX;
                        panY += mouseY - lastMouseY;
                    }
                    
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                    draw();
                }
            });

            // Handle mouse up event to stop dragging
            canvas.addEventListener('mouseup', () => {
                draggedNodeId = null;
                lastMouseX = undefined;
                lastMouseY = undefined;
                canvas.style.cursor = 'grab';
            });
            
            // Handle double-click for inline renaming
            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const nodeId = isInsideNode(mouseX, mouseY);
                if (nodeId !== null) {
                    if (editingNodeId === nodeId) {
                        // Double-click while editing - toggle text selection
                        textSelected = !textSelected;
                    } else {
                        // First double-click - start editing
                        editingNodeId = nodeId;
                        selectedNodeId = nodeId;
                        textSelected = false;
                        const node = nodes.find(n => n.id === nodeId);
                        cursorPosition = node ? node.text.length : 0;
                    }
                    draw();
                }
            });

            // Handle keyboard input for editing and connections
            window.addEventListener('keydown', (e) => {
                // Handle Delete key for selected nodes
                if (e.key === 'Delete' && editingNodeId === null && selectedNodeId !== null) {
                    e.preventDefault();
                    deleteNode(selectedNodeId);
                    selectedNodeId = null;
                    return;
                }
                
                // Handle Enter for connecting nodes
                if (e.key === 'Enter' && editingNodeId === null && multiSelectedNodes.length > 1) {
                        e.preventDefault();
                        // Connect all nodes in sequence
                        for (let i = 0; i < multiSelectedNodes.length - 1; i++) {
                            const parentNode = nodes.find(n => n.id === multiSelectedNodes[i]);
                            const childNode = nodes.find(n => n.id === multiSelectedNodes[i + 1]);
                            
                            if (parentNode && childNode) {
                                // Only connect if not already connected
                                const isConnectedForward = childNode.parent === parentNode.id;
                                const isConnectedReverse = parentNode.parent === childNode.id;
                                
                                if (!isConnectedForward && !isConnectedReverse) {
                                    // Only connect if child doesn't already have a parent
                                    if (childNode.parent === null) {
                                        childNode.parent = parentNode.id;
                                        if (!parentNode.children.includes(childNode.id)) {
                                            parentNode.children.push(childNode.id);
                                        }
                                    }
                                }
                            }
                        }
                        multiSelectedNodes = [];
                        cleanupConnections();
                        draw();
                        return;
                }
                
                if (editingNodeId !== null) {
                    e.preventDefault(); // Prevent default browser behavior when editing
                    const editingNode = nodes.find(n => n.id === editingNodeId);
                    if (editingNode) {
                        if (e.key === 'Enter') {
                            if (e.shiftKey) {
                                // Shift+Enter: Add new line
                                if (textSelected) {
                                    editingNode.text = '\n';
                                    cursorPosition = 1;
                                    textSelected = false;
                                } else {
                                    editingNode.text = editingNode.text.slice(0, cursorPosition) + '\n' + editingNode.text.slice(cursorPosition);
                                    cursorPosition++;
                                }
                                draw();
                            } else {
                                // Regular Enter: Exit editing
                                editingNodeId = null;
                                textSelected = false;
                                draw();
                            }
                        } else if (e.key === 'Escape') {
                            editingNodeId = null;
                            textSelected = false;
                            draw();
                        } else if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                            textSelected = true;
                            draw();
                        } else if (e.key === 'ArrowLeft') {
                            if (!textSelected) {
                                cursorPosition = Math.max(0, cursorPosition - 1);
                                draw();
                            }
                        } else if (e.key === 'ArrowRight') {
                            if (!textSelected) {
                                cursorPosition = Math.min(editingNode.text.length, cursorPosition + 1);
                                draw();
                            }
                        } else if (e.key === 'Home') {
                            cursorPosition = 0;
                            textSelected = false;
                            draw();
                        } else if (e.key === 'End') {
                            cursorPosition = editingNode.text.length;
                            textSelected = false;
                            draw();
                        } else if (e.key === 'Backspace') {
                            if (textSelected) {
                                editingNode.text = '';
                                cursorPosition = 0;
                                textSelected = false;
                            } else if (cursorPosition > 0) {
                                editingNode.text = editingNode.text.slice(0, cursorPosition - 1) + editingNode.text.slice(cursorPosition);
                                cursorPosition--;
                            }
                            draw();
                        } else if (e.key === 'Delete') {
                            if (textSelected) {
                                editingNode.text = '';
                                cursorPosition = 0;
                                textSelected = false;
                            } else if (cursorPosition < editingNode.text.length) {
                                editingNode.text = editingNode.text.slice(0, cursorPosition) + editingNode.text.slice(cursorPosition + 1);
                            }
                            draw();
                        } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                            if (textSelected) {
                                editingNode.text = e.key;
                                cursorPosition = 1;
                                textSelected = false;
                            } else {
                                editingNode.text = editingNode.text.slice(0, cursorPosition) + e.key + editingNode.text.slice(cursorPosition);
                                cursorPosition++;
                            }
                            draw();
                        }
                    }
                }
            });

            // Handle right-click context menu
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                selectedNodeId = isInsideNode(mouseX, mouseY);
                selectedConnectionId = isOnConnection(mouseX, mouseY);

                // Position the menu
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.display = 'block';

                // Enable/disable menu options based on selection
                if (selectedNodeId !== null) {
                    menuAddBranchBtn.classList.remove('disabled');
                    menuRenameBtn.classList.remove('disabled');
                    menuDeleteBtn.classList.remove('disabled');
                    menuDeleteConnectionBtn.classList.add('disabled');
                } else if (selectedConnectionId !== null) {
                    menuAddBranchBtn.classList.add('disabled');
                    menuRenameBtn.classList.add('disabled');
                    menuDeleteBtn.classList.add('disabled');
                    menuDeleteConnectionBtn.classList.remove('disabled');
                } else {
                    menuAddBranchBtn.classList.add('disabled');
                    menuRenameBtn.classList.add('disabled');
                    menuDeleteBtn.classList.add('disabled');
                    menuDeleteConnectionBtn.classList.add('disabled');
                }
            });

            // Hide the menu on any click outside the menu
            window.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.style.display = 'none';
                    // Do not force-exit editing on generic clicks; canvas handlers manage that
                }
            });


            
            // Toggle for curved/straight lines
            curvedLinesToggle.addEventListener('click', () => {
                curvedLinesEnabled = !curvedLinesEnabled;
                curvedLinesToggle.classList.toggle('bg-indigo-600', curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('text-white', curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('border-indigo-600', curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('bg-gray-100', !curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('dark:bg-slate-800', !curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('text-gray-800', !curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('dark:text-gray-100', !curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('border-gray-200', !curvedLinesEnabled);
                curvedLinesToggle.classList.toggle('dark:border-slate-700', !curvedLinesEnabled);
                draw();
            });

            // --- Context Menu Actions ---

            menuCreateBtn.addEventListener('click', () => {
                if (contextMenu.style.display === 'block') {
                    const rect = canvas.getBoundingClientRect();
                    const menuX = (parseInt(contextMenu.style.left) - rect.left - panX) / zoomScale;
                    const menuY = (parseInt(contextMenu.style.top) - rect.top - panY) / zoomScale;
                    createNode(menuX, menuY);
                    contextMenu.style.display = 'none';
                }
            });

            menuAddBranchBtn.addEventListener('click', () => {
                if (selectedNodeId !== null && contextMenu.style.display === 'block') {
                    const selectedNode = nodes.find(n => n.id === selectedNodeId);
                    if (selectedNode) {
                        createNode(selectedNode.x + 150, selectedNode.y, '', selectedNode.id, true);
                    }
                    contextMenu.style.display = 'none';
                }
            });

            menuDeleteBtn.addEventListener('click', () => {
                if (selectedNodeId !== null && contextMenu.style.display === 'block') {
                    deleteNode(selectedNodeId);
                    selectedNodeId = null;
                    contextMenu.style.display = 'none';
                }
            });

            menuRenameBtn.addEventListener('click', () => {
                if (selectedNodeId !== null && contextMenu.style.display === 'block') {
                    editingNodeId = selectedNodeId;
                    textSelected = false;
                    const node = nodes.find(n => n.id === selectedNodeId);
                    cursorPosition = node ? node.text.length : 0;
                    contextMenu.style.display = 'none';
                    draw();
                }
            });

            menuDeleteConnectionBtn.addEventListener('click', () => {
                if (selectedConnectionId !== null && contextMenu.style.display === 'block') {
                    deleteConnection(selectedConnectionId.parentId, selectedConnectionId.childId);
                    selectedConnectionId = null;
                    contextMenu.style.display = 'none';
                }
            });

            // Fit to view: zoom/pan to include all nodes with padding
            function fitToView() {
                if (nodes.length === 0) return;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (const n of nodes) {
                    minX = Math.min(minX, n.x);
                    minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x + (n.width || 100));
                    maxY = Math.max(maxY, n.y + (n.height || 40));
                }
                const padding = 80;
                const w = maxX - minX + padding * 2;
                const h = maxY - minY + padding * 2;
                const scaleX = canvas.width / w;
                const scaleY = canvas.height / h;
                const newZoom = Math.max(0.1, Math.min(3, Math.min(scaleX, scaleY)));
                zoomScale = newZoom;
                const worldCenterX = minX + (maxX - minX) / 2;
                const worldCenterY = minY + (maxY - minY) / 2;
                panX = canvas.width / 2 - worldCenterX * zoomScale;
                panY = canvas.height / 2 - worldCenterY * zoomScale;
                draw();
            }
            fitViewBtn.addEventListener('click', fitToView);

            // Theme toggle (persist in localStorage)
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const savedTheme = localStorage.getItem('theme');
            if ((savedTheme === 'dark') || (!savedTheme && prefersDark)) {
                document.documentElement.classList.add('dark');
            }
            themeToggle.addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                const isDark = document.documentElement.classList.contains('dark');
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                draw();
            });

            // Download functionality
            function downloadMindMap() {
                const data = {
                    nodes,
                    zoomScale,
                    panX,
                    panY,
                    curvedLinesEnabled,
                    nextNodeId
                };
                const now = new Date();
                const filename = `${now.getDate().toString().padStart(2, '0')}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getFullYear().toString().slice(-2)}${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}.rxt`;
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            // Open functionality
            function openMindMap(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        nodes = data.nodes || [];
                        zoomScale = data.zoomScale || 1;
                        panX = data.panX || 0;
                        panY = data.panY || 0;
                        curvedLinesEnabled = data.curvedLinesEnabled !== undefined ? data.curvedLinesEnabled : true;
                        nextNodeId = data.nextNodeId || (Math.max(...nodes.map(n => n.id), 0) + 1);
                        
                        // Update curved lines toggle appearance
                        curvedLinesToggle.classList.toggle('bg-indigo-600', curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('text-white', curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('border-indigo-600', curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('bg-gray-100', !curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('dark:bg-slate-800', !curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('text-gray-800', !curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('dark:text-gray-100', !curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('border-gray-200', !curvedLinesEnabled);
                        curvedLinesToggle.classList.toggle('dark:border-slate-700', !curvedLinesEnabled);
                        
                        draw();
                    } catch (error) {
                        alert('Error opening file: Invalid format');
                    }
                };
                reader.readAsText(file);
            }

            // Event listeners for download and open
            downloadBtn.addEventListener('click', downloadMindMap);
            openBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    openMindMap(e.target.files[0]);
                    e.target.value = ''; // Reset input
                }
            });

            // Help modal
            function showHelp(show) {
                if (!helpModal) return;
                helpModal.classList.toggle('hidden', !show);
                helpModal.classList.toggle('flex', show);
            }
            if (helpBtn && helpCloseBtn && helpModal) {
                helpBtn.addEventListener('click', () => showHelp(true));
                helpCloseBtn.addEventListener('click', () => showHelp(false));
                helpModal.addEventListener('click', (e) => {
                    if (e.target === helpModal || e.target === helpModal.firstElementChild) showHelp(false);
                });
            }
        };
    </script>
</body>
</html>
