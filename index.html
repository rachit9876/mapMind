<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map - Markdown Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg: #f5f6fa;
            --bg-secondary: #ffffff;
            --border: #e0e0e0;
            --text-primary: #222;
            --text-secondary: #888;
            --accent: #007aff;
            --accent-hover: #0051a8;
            --node-bg: #fff;
            --node-border: #e0e0e0;
            --node-text: #222;
            --node-shadow: 0 4px 16px rgba(0,0,0,0.08);
            --line: #d1d5db;
            --dot: #e0e0e0;
            --success: #22c55e;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
        }
        html.dark {
            --bg: #292929;
            --bg-secondary: #2c2f36;
            --border: #444;
            --text-primary: #ffffff;
            --text-secondary: #bbb;
            --accent: #0a84ff;
            --accent-hover: #0051a8;
            --node-bg: #000000;
            --node-border: #444;
            --node-text: #ffffff;
            --node-shadow: 0 4px 16px rgba(0,0,0,0.18);
            --line: #444;
            --dot: #444;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #f87171;
            --info: #60a5fa;
        }
        body {
            background-color: var(--bg);
            color: var(--text-primary);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        .dot-background {
            background-image: radial-gradient(circle, var(--dot) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.2rem;
            height: 2.2rem;
            border-radius: 0.7rem;
            box-shadow: 0 1px 4px rgba(0,0,0,0.04);
            transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
        }
        .btn:active {
            transform: scale(0.95);
        }
        .btn-secondary {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover {
            background-color: var(--border);
        }
        .btn-primary {
            background-color: var(--accent);
            color: #fff;
            border: none;
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
        }
        #context-menu {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
        }
        #context-menu li {
            border-radius: 0.4rem;
            margin: 2px 0;
            transition: background-color 0.2s;
        }
        #context-menu li:hover {
            background-color: var(--accent);
            color: #fff;
        }
        .rounded-lg {
            border-radius: 1rem !important;
        }
        .flex {
            gap: 0.5rem;
        }
        .absolute.left-1\/2 {
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        .tooltip {
            position: relative;
        }
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .tooltip:hover::after {
            opacity: 1;
        }
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 1000;
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
        }
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        .notification.success {
            border-left: 4px solid var(--success);
        }
        .notification.error {
            border-left: 4px solid var(--danger);
        }
        .notification.info {
            border-left: 4px solid var(--info);
        }
        .markdown-toolbar {
            display: flex;
            gap: 4px;
            padding: 4px;
            background-color: var(--bg);
            border-radius: 6px;
            margin-bottom: 4px;
        }
        .markdown-toolbar button {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background-color: transparent;
            color: var(--text-secondary);
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .markdown-toolbar button:hover {
            background-color: var(--border);
            color: var(--text-primary);
        }
        .markdown-toolbar button.active {
            background-color: var(--accent);
            color: white;
        }
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex flex-col h-screen">
    <header class="bg-[var(--bg-secondary)]/80 backdrop-blur-xl border-b border-[var(--border)] p-2 flex justify-between items-center z-20">
        <div class="flex items-center gap-2">
            <h1 class="text-2xl font-semibold tracking-tight" style="letter-spacing: -0.02em;">Mind Map</h1>
            <span class="text-xs px-2 py-1 bg-[var(--accent)] text-white rounded-full">Markdown Edition</span>
        </div>
        <div class="absolute left-1/2 -translate-x-1/2 flex items-center gap-2 p-2 bg-[var(--bg-secondary)] border border-[var(--border)] rounded-lg shadow-md">
            <button id="undoBtn" class="btn btn-secondary tooltip" data-tooltip="Undo (Ctrl+Z)" disabled>
                <i class="fas fa-undo"></i>
            </button>
            <button id="redoBtn" class="btn btn-secondary tooltip" data-tooltip="Redo (Ctrl+Y)" disabled>
                <i class="fas fa-redo"></i>
            </button>
            <div class="w-px h-6 bg-[var(--border)] mx-1"></div>
            <button id="addNodeBtn" class="btn btn-primary tooltip" data-tooltip="Add Node (N)">
                <i class="fas fa-plus"></i>
            </button>
        </div>
        <div class="flex items-center gap-2">
            <div class="flex items-center gap-1 p-1 bg-[var(--bg)] border border-[var(--border)] rounded-lg">
                <button id="zoomOutBtn" class="btn btn-secondary tooltip" data-tooltip="Zoom Out (-)">
                    <i class="fas fa-minus"></i>
                </button>
                <div id="zoomIndicator" class="text-sm font-semibold w-16 text-center">100%</div>
                <button id="zoomInBtn" class="btn btn-secondary tooltip" data-tooltip="Zoom In (+)">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <button id="fitViewBtn" class="btn btn-secondary tooltip" data-tooltip="Fit to View (F)">
                <i class="fas fa-expand"></i>
            </button>
            <button id="importBtn" class="btn btn-secondary tooltip" data-tooltip="Import">
                <i class="fas fa-file-import"></i>
            </button>
            <button id="exportBtn" class="btn btn-secondary tooltip" data-tooltip="Export">
                <i class="fas fa-file-export"></i>
            </button>
            <div class="w-px h-6 bg-[var(--border)] mx-1"></div>
            <button id="markdownToggle" class="btn btn-secondary tooltip" data-tooltip="Toggle Markdown Mode (M)">
                <i id="markdown-icon-off" class="fas fa-file-alt"></i>
                <i id="markdown-icon-on" class="fas fa-file-code hidden"></i>
            </button>
            <button id="themeToggle" class="btn btn-secondary tooltip" data-tooltip="Toggle Theme (T)">
                <i id="theme-icon-light" class="fas fa-sun"></i>
                <i id="theme-icon-dark" class="fas fa-moon hidden"></i>
            </button>
        </div>
    </header>
    <main class="flex-1 dot-background relative">
    <canvas id="mindMapCanvas"></canvas>
    <div id="node-editor-container" class="absolute hidden z-10">
        <div class="markdown-toolbar">
            <button id="md-bold" class="tooltip" data-tooltip="Bold"><i class="fas fa-bold"></i></button>
            <button id="md-italic" class="tooltip" data-tooltip="Italic"><i class="fas fa-italic"></i></button>
            <button id="md-heading" class="tooltip" data-tooltip="Heading"><i class="fas fa-heading"></i></button>
            <button id="md-link" class="tooltip" data-tooltip="Link"><i class="fas fa-link"></i></button>
            <button id="md-image" class="tooltip" data-tooltip="Image"><i class="fas fa-image"></i></button>
            <button id="md-code" class="tooltip" data-tooltip="Code"><i class="fas fa-code"></i></button>
            <button id="md-quote" class="tooltip" data-tooltip="Quote"><i class="fas fa-quote-left"></i></button>
            <button id="md-list" class="tooltip" data-tooltip="List"><i class="fas fa-list-ul"></i></button>
            <button id="md-table" class="tooltip" data-tooltip="Table"><i class="fas fa-table"></i></button>
        </div>
        <textarea id="node-editor" class="text-left outline-none bg-[var(--node-bg)] border border-[var(--node-border)] text-[var(--node-text)] rounded-lg p-2 resize-none overflow-hidden shadow-lg" rows="1" wrap="off"></textarea>
    </div>
    </main>
    <div id="context-menu" class="absolute hidden z-30 rounded-lg shadow-lg w-48">
        <ul class="py-1">
            <li id="menu-add-child" class="px-4 py-2 cursor-pointer flex items-center gap-2">
                <i class="fas fa-sitemap"></i> Add Child
            </li>
            <li id="menu-add-node" class="px-4 py-2 cursor-pointer flex items-center gap-2">
                <i class="fas fa-plus-circle"></i> Add Node
            </li>
            <li id="menu-connect" class="px-4 py-2 cursor-pointer flex items-center gap-2">
                <i class="fas fa-link"></i> Connect
            </li>
            <li id="menu-disconnect" class="px-4 py-2 cursor-pointer flex items-center gap-2">
                <i class="fas fa-unlink"></i> Disconnect
            </li>
            <li id="menu-delete-node" class="px-4 py-2 cursor-pointer flex items-center gap-2">
                <i class="fas fa-trash"></i> Delete Node
            </li>
        </ul>
    </div>
    
    <input type="file" id="file-input" class="hidden" accept=".rxt">
    <div id="notification" class="notification"></div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mindMapCanvas');
            const ctx = canvas.getContext('2d');
            const nodeEditor = document.getElementById('node-editor');
            const nodeEditorContainer = document.getElementById('node-editor-container');
            const contextMenu = document.getElementById('context-menu');
            const notification = document.getElementById('notification');
            
            let state = {
                nodes: [],
                pan: { x: 0, y: 0 },
                zoom: 1,
                nextNodeId: 1,
                selectedNodeId: null,
                editingNodeId: null,
                draggingNodeId: null,
                dragStart: { x: 0, y: 0 },
                isDragging: false,
                isPanning: false,
                history: [],
                historyIndex: -1,
                connecting: false,
                markdownMode: true,
                autoSave: true,
                autoSaveInterval: null,
                lastSaved: null
            };
            
            const dom = {
                undoBtn: document.getElementById('undoBtn'),
                redoBtn: document.getElementById('redoBtn'),
                addNodeBtn: document.getElementById('addNodeBtn'),
                zoomInBtn: document.getElementById('zoomInBtn'),
                zoomOutBtn: document.getElementById('zoomOutBtn'),
                zoomIndicator: document.getElementById('zoomIndicator'),
                fitViewBtn: document.getElementById('fitViewBtn'),
                importBtn: document.getElementById('importBtn'),
                exportBtn: document.getElementById('exportBtn'),
                markdownToggle: document.getElementById('markdownToggle'),
                markdownIconOff: document.getElementById('markdown-icon-off'),
                markdownIconOn: document.getElementById('markdown-icon-on'),
                themeToggle: document.getElementById('themeToggle'),
                themeIconLight: document.getElementById('theme-icon-light'),
                themeIconDark: document.getElementById('theme-icon-dark'),
                fileInput: document.getElementById('file-input'),
                // Markdown toolbar buttons
                mdBold: document.getElementById('md-bold'),
                mdItalic: document.getElementById('md-italic'),
                mdHeading: document.getElementById('md-heading'),
                mdLink: document.getElementById('md-link'),
                mdImage: document.getElementById('md-image'),
                mdCode: document.getElementById('md-code'),
                mdQuote: document.getElementById('md-quote'),
                mdList: document.getElementById('md-list'),
                mdTable: document.getElementById('md-table')
            };
            
            const FONT_SIZE = 16;
            const NODE_PADDING = 16;
            const LINE_HEIGHT = 1.4;
            
            // --- Notification System ---
            const showNotification = (message, type = 'info', duration = 3000) => {
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, duration);
            };
            
            // --- Core Functions ---
            const resizeCanvas = () => {
                const header = document.querySelector('header');
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = (window.innerHeight - header.offsetHeight) * window.devicePixelRatio;
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight - header.offsetHeight}px`;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                requestRedraw();
            };
            
            const requestRedraw = () => {
                requestAnimationFrame(draw);
            };
            
            const draw = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(state.pan.x, state.pan.y);
                ctx.scale(state.zoom, state.zoom);
                drawConnections();
                drawNodes();
                if (state.connecting && state.selectedNodeId) {
                    drawConnectionLineToCursor();
                }
                ctx.restore();
            };
            
            const drawNodes = () => {
                ctx.font = `500 ${FONT_SIZE}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                for (const node of state.nodes) {
                    updateNodeDimensions(node);
                    
                    // Draw node background
                    ctx.fillStyle = getCssVar('--node-bg');
                    ctx.strokeStyle = getCssVar(node.id === state.selectedNodeId ? '--accent' : '--node-border');
                    ctx.lineWidth = 2;
                    ctx.shadowColor = getCssVar('--node-shadow');
                    ctx.shadowBlur = 10;
                    fillRoundedRect(ctx, node.x, node.y, node.width, node.height, 8);
                    strokeRoundedRect(ctx, node.x, node.y, node.width, node.height, 8);
                    
                    ctx.shadowColor = 'transparent';
                    
                    // Draw node content
                    if (node.id !== state.editingNodeId) {
                        ctx.fillStyle = getCssVar('--node-text');
                        if (state.markdownMode) {
                            renderMarkdownText(ctx, node.text, node.x + NODE_PADDING, node.y + NODE_PADDING);
                        } else {
                            const lines = node.text.split('\n');
                            const lineHeight = FONT_SIZE * LINE_HEIGHT;
                            const startY = node.y + node.height / 2 - ((lines.length - 1) * lineHeight) / 2;
                            lines.forEach((line, index) => {
                                ctx.fillText(line, node.x + NODE_PADDING, startY + index * lineHeight);
                            });
                        }
                    }
                }
            };
            
            const drawConnections = () => {
                ctx.strokeStyle = getCssVar('--line');
                ctx.lineWidth = 2.5;
                
                for (const node of state.nodes) {
                    if (node.parentId) {
                        const parent = findNodeById(node.parentId);
                        if (parent) {
                            const start = { x: parent.x + parent.width / 2, y: parent.y + parent.height / 2 };
                            const end = { x: node.x + node.width / 2, y: node.y + node.height / 2 };
                            
                            // Calculate control points for bezier curve
                            const controlPoint1 = { x: start.x + 50, y: start.y };
                            const controlPoint2 = { x: end.x - 50, y: end.y };
                            
                            ctx.beginPath();
                            ctx.moveTo(start.x, start.y);
                            ctx.bezierCurveTo(
                                controlPoint1.x, controlPoint1.y,
                                controlPoint2.x, controlPoint2.y,
                                end.x, end.y
                            );
                            ctx.stroke();
                        }
                    }
                }
            };
            
            const drawConnectionLineToCursor = () => {
                const startNode = findNodeById(state.selectedNodeId);
                if (!startNode) return;
                
                const start = { x: startNode.x + startNode.width / 2, y: startNode.y + startNode.height / 2 };
                const end = screenToWorld(state.dragStart.x, state.dragStart.y);
                
                ctx.strokeStyle = getCssVar('--accent');
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
                ctx.setLineDash([]);
            };
            
            // --- State & History ---
            const saveState = () => {
                const snapshot = JSON.stringify({ 
                    nodes: state.nodes, 
                    nextNodeId: state.nextNodeId 
                });
                
                state.historyIndex++;
                state.history = state.history.slice(0, state.historyIndex);
                state.history.push(snapshot);
                
                updateHistoryButtons();
                saveToLocalStorage();
                
                // Update last saved timestamp
                state.lastSaved = new Date();
            };
            
            const saveToLocalStorage = () => {
                const saveData = {
                    nodes: state.nodes,
                    nextNodeId: state.nextNodeId,
                    zoom: state.zoom,
                    pan: state.pan,
                    markdownMode: state.markdownMode
                };
                
                try {
                    localStorage.setItem('mindmap-data', JSON.stringify(saveData));
                } catch (e) {
                    console.error('Failed to save to localStorage:', e);
                    showNotification('Failed to save data. Storage might be full.', 'error');
                }
            };
            
            const loadFromLocalStorage = () => {
                const saved = localStorage.getItem('mindmap-data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        state.nodes = data.nodes || [];
                        state.nextNodeId = data.nextNodeId || 1;
                        state.zoom = data.zoom || 1;
                        state.pan = data.pan || { x: 0, y: 0 };
                        if (data.markdownMode !== undefined) {
                            state.markdownMode = data.markdownMode;
                        }
                        return true;
                    } catch (e) {
                        console.error('Failed to load saved data:', e);
                        showNotification('Failed to load saved data.', 'error');
                    }
                }
                return false;
            };
            
            const undo = () => {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    loadState(state.history[state.historyIndex]);
                    showNotification('Undo successful', 'info');
                }
            };
            
            const redo = () => {
                if (state.historyIndex < state.history.length - 1) {
                    state.historyIndex++;
                    loadState(state.history[state.historyIndex]);
                    showNotification('Redo successful', 'info');
                }
            };
            
            const loadState = (snapshot) => {
                const loaded = JSON.parse(snapshot);
                state.nodes = loaded.nodes;
                state.nextNodeId = loaded.nextNodeId;
                state.selectedNodeId = null;
                state.editingNodeId = null;
                hideNodeEditor();
                updateHistoryButtons();
                requestRedraw();
            };
            
            const updateHistoryButtons = () => {
                dom.undoBtn.disabled = state.historyIndex <= 0;
                dom.redoBtn.disabled = state.historyIndex >= state.history.length - 1;
            };
            
            // --- Auto-save functionality ---
            const setupAutoSave = () => {
                if (state.autoSaveInterval) {
                    clearInterval(state.autoSaveInterval);
                }
                
                if (state.autoSave) {
                    state.autoSaveInterval = setInterval(() => {
                        if (state.editingNodeId) {
                            // Don't auto-save while editing
                            return;
                        }
                        
                        saveToLocalStorage();
                        const now = new Date();
                        if (state.lastSaved && (now - state.lastSaved) > 60000) {
                            showNotification('Auto-saved', 'success', 1000);
                            state.lastSaved = now;
                        }
                    }, 5000); // Check every 5 seconds
                }
            };
            
            // --- Node Management ---
            const createNode = (x, y, text = 'New Idea', parentId = null) => {
                const newNode = {
                    id: state.nextNodeId++,
                    text,
                    x, y,
                    width: 0, height: 0,
                    parentId,
                };
                
                updateNodeDimensions(newNode);
                state.nodes.push(newNode);
                return newNode;
            };
            
            const deleteNode = (nodeId) => {
                // First, find all children and disconnect them
                const children = state.nodes.filter(n => n.parentId === nodeId);
                children.forEach(child => {
                    child.parentId = null;
                });
                
                // Then delete the node
                state.nodes = state.nodes.filter(n => n.id !== nodeId);
            };
            
            const updateNodeDimensions = (node) => {
                ctx.font = `500 ${FONT_SIZE}px sans-serif`;
                
                if (state.markdownMode) {
                    const dimensions = measureMarkdownText(ctx, node.text);
                    node.width = dimensions.width + NODE_PADDING * 2;
                    node.height = dimensions.height + NODE_PADDING * 2;
                } else {
                    const lines = node.text.split('\n');
                    const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width), 80);
                    const lineHeight = FONT_SIZE * LINE_HEIGHT;
                    node.width = maxWidth + NODE_PADDING * 1.5;
                    node.height = lines.length * lineHeight + NODE_PADDING * 2;
                }
            };
            
            const updateEditorSize = () => {
                if (!state.editingNodeId) return;
                
                const node = findNodeById(state.editingNodeId);
                if (!node) return;
                
                const screenPos = worldToScreen(node.x, node.y);
                nodeEditorContainer.style.left = `${screenPos.x}px`;
                nodeEditorContainer.style.top = `${screenPos.y}px`;
                nodeEditor.style.width = `${node.width * state.zoom}px`;
                nodeEditor.style.height = `${node.height * state.zoom}px`;
            };
            
            const autoResizeEditor = () => {
                nodeEditor.style.height = 'auto';
                nodeEditor.style.height = `${nodeEditor.scrollHeight}px`;
            };
            
            const startEditingNode = (nodeId) => {
                const node = findNodeById(nodeId);
                if (!node) return;
                
                state.editingNodeId = nodeId;
                const screenPos = worldToScreen(node.x, node.y);
                
                nodeEditor.value = node.text;
                nodeEditor.style.fontSize = `${FONT_SIZE * state.zoom}px`;
                nodeEditor.style.padding = `${NODE_PADDING * state.zoom}px`;
                nodeEditor.style.lineHeight = `${FONT_SIZE * LINE_HEIGHT * state.zoom}px`;
                
                nodeEditorContainer.classList.remove('hidden');
                updateEditorSize();
                autoResizeEditor();
                
                nodeEditor.focus();
                nodeEditor.select();
                
                requestRedraw();
            };
            
            const finishEditingNode = () => {
                if (!state.editingNodeId) return;
                
                const node = findNodeById(state.editingNodeId);
                if (node) {
                    node.text = nodeEditor.value;
                    saveState();
                }
                
                hideNodeEditor();
                requestRedraw();
            };
            
            const hideNodeEditor = () => {
                state.editingNodeId = null;
                nodeEditorContainer.classList.add('hidden');
            };
            
            // --- Markdown Toolbar Functions ---
            const insertMarkdown = (before, after, defaultText = '') => {
                const start = nodeEditor.selectionStart;
                const end = nodeEditor.selectionEnd;
                const selectedText = nodeEditor.value.substring(start, end) || defaultText;
                const replacement = before + selectedText + after;
                
                nodeEditor.value = nodeEditor.value.substring(0, start) + replacement + nodeEditor.value.substring(end);
                
                // Set cursor position
                const newCursorPos = start + before.length + selectedText.length;
                nodeEditor.setSelectionRange(newCursorPos, newCursorPos);
                
                nodeEditor.focus();
                autoResizeEditor();
                
                // Trigger input event to update node size in real-time
                nodeEditor.dispatchEvent(new Event('input'));
            };
            
            const insertMarkdownLink = () => {
                const start = nodeEditor.selectionStart;
                const end = nodeEditor.selectionEnd;
                const selectedText = nodeEditor.value.substring(start, end) || 'link text';
                const replacement = `[${selectedText}](url)`;
                
                nodeEditor.value = nodeEditor.value.substring(0, start) + replacement + nodeEditor.value.substring(end);
                
                // Set cursor position to select the URL
                const newCursorStart = start + selectedText.length + 3;
                const newCursorEnd = newCursorStart + 3;
                nodeEditor.setSelectionRange(newCursorStart, newCursorEnd);
                
                nodeEditor.focus();
                autoResizeEditor();
                
                // Trigger input event to update node size in real-time
                nodeEditor.dispatchEvent(new Event('input'));
            };
            
            const insertMarkdownImage = () => {
                const start = nodeEditor.selectionStart;
                const replacement = `![alt text](image-url)`;
                
                nodeEditor.value = nodeEditor.value.substring(0, start) + replacement + nodeEditor.value.substring(start);
                
                // Set cursor position to select the URL
                const newCursorStart = start + 12;
                const newCursorEnd = newCursorStart + 10;
                nodeEditor.setSelectionRange(newCursorStart, newCursorEnd);
                
                nodeEditor.focus();
                autoResizeEditor();
                
                // Trigger input event to update node size in real-time
                nodeEditor.dispatchEvent(new Event('input'));
            };
            
            const insertMarkdownTable = () => {
                const table = `
| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |
`.trim();
                
                const start = nodeEditor.selectionStart;
                nodeEditor.value = nodeEditor.value.substring(0, start) + table + nodeEditor.value.substring(start);
                
                nodeEditor.focus();
                autoResizeEditor();
                
                // Trigger input event to update node size in real-time
                nodeEditor.dispatchEvent(new Event('input'));
            };
            
            // --- Event Handlers ---
            const setupEventListeners = () => {
                // Canvas events
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
                canvas.addEventListener('mouseleave', onMouseUp);
                canvas.addEventListener('wheel', onWheel);
                canvas.addEventListener('dblclick', onDoubleClick);
                canvas.addEventListener('contextmenu', onContextMenu);
                
                // Node editor events
                nodeEditor.addEventListener('blur', finishEditingNode);
                nodeEditor.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        if (e.shiftKey) {
                            // Allow new line with Shift+Enter
                            setTimeout(() => {
                                autoResizeEditor();
                            }, 0);
                        } else {
                            e.preventDefault();
                            finishEditingNode();
                        }
                    }
                    if (e.key === 'Escape') hideNodeEditor();
                });
                
                nodeEditor.addEventListener('input', () => {
                    // Update node size in real-time
                    if (state.editingNodeId) {
                        const node = findNodeById(state.editingNodeId);
                        if (node) {
                            node.text = nodeEditor.value;
                            updateNodeDimensions(node);
                            updateEditorSize();
                            autoResizeEditor();
                            requestRedraw();
                        }
                    }
                });
                
                // Markdown toolbar events
                dom.mdBold.addEventListener('click', () => insertMarkdown('**', '**', 'bold text'));
                dom.mdItalic.addEventListener('click', () => insertMarkdown('*', '*', 'italic text'));
                dom.mdHeading.addEventListener('click', () => insertMarkdown('## ', '', 'Heading'));
                dom.mdLink.addEventListener('click', insertMarkdownLink);
                dom.mdImage.addEventListener('click', insertMarkdownImage);
                dom.mdCode.addEventListener('click', () => insertMarkdown('`', '`', 'code'));
                dom.mdQuote.addEventListener('click', () => insertMarkdown('> ', '', 'Quote'));
                dom.mdList.addEventListener('click', () => insertMarkdown('- ', '', 'List item'));
                dom.mdTable.addEventListener('click', insertMarkdownTable);
                
                // UI button events
                dom.addNodeBtn.addEventListener('click', () => {
                    const center = screenToWorld(canvas.clientWidth / 2, canvas.clientHeight / 2);
                    const newNode = createNode(center.x, center.y);
                    state.selectedNodeId = newNode.id;
                    saveState();
                    requestRedraw();
                    startEditingNode(newNode.id);
                });
                
                dom.zoomInBtn.addEventListener('click', () => zoom(1.2));
                dom.zoomOutBtn.addEventListener('click', () => zoom(0.8));
                dom.fitViewBtn.addEventListener('click', fitView);
                dom.undoBtn.addEventListener('click', undo);
                dom.redoBtn.addEventListener('click', redo);
                dom.markdownToggle.addEventListener('click', toggleMarkdown);
                dom.themeToggle.addEventListener('click', toggleTheme);
                dom.importBtn.addEventListener('click', () => dom.fileInput.click());
                dom.exportBtn.addEventListener('click', exportAsRXT);
                dom.fileInput.addEventListener('change', importRXT);
                
                // Window events
                window.addEventListener('resize', resizeCanvas);
                window.addEventListener('keydown', onKeyDown);
                document.addEventListener('click', () => hideContextMenu());
                
                // Auto-save on page unload
                window.addEventListener('beforeunload', () => {
                    saveToLocalStorage();
                });
            };
            
            const onMouseDown = (e) => {
                if (e.button === 2) return; // Disable right-click drag
                
                hideContextMenu();
                finishEditingNode();
                
                const pos = getMousePos(e);
                const clickedNodeId = findNodeAt(pos.x, pos.y);
                
                if (state.connecting) {
                    if (clickedNodeId && clickedNodeId !== state.selectedNodeId) {
                        const child = findNodeById(clickedNodeId);
                        if (child) {
                            child.parentId = state.selectedNodeId;
                            saveState();
                        }
                    }
                    state.connecting = false;
                    requestRedraw();
                    return;
                }
                
                // Check for link click before setting up drag
                if (clickedNodeId && state.markdownMode) {
                    const node = findNodeById(clickedNodeId);
                    if (node) {
                        const worldPos = screenToWorld(pos.x, pos.y);
                        const relativeX = worldPos.x - node.x - NODE_PADDING;
                        const relativeY = worldPos.y - node.y - NODE_PADDING;
                        const clickedLink = findLinkAtPosition(node.text, relativeX, relativeY);
                        if (clickedLink) {
                            window.open(clickedLink, '_blank');
                            return;
                        }
                    }
                }
                
                state.selectedNodeId = clickedNodeId;
                
                if (clickedNodeId) {
                    state.isDragging = true;
                    state.draggingNodeId = clickedNodeId;
                } else {
                    state.isPanning = true;
                }
                
                state.dragStart = { x: pos.x, y: pos.y };
                requestRedraw();
            };
            
            const onMouseMove = (e) => {
                const pos = getMousePos(e);
                const dx = (pos.x - state.dragStart.x);
                const dy = (pos.y - state.dragStart.y);
                
                // Check if hovering over a link
                const clickedNodeId = findNodeAt(pos.x, pos.y);
                if (clickedNodeId && state.markdownMode && !state.isDragging && !state.isPanning) {
                    const node = findNodeById(clickedNodeId);
                    if (node) {
                        const worldPos = screenToWorld(pos.x, pos.y);
                        const relativeX = worldPos.x - node.x - NODE_PADDING;
                        const relativeY = worldPos.y - node.y - NODE_PADDING;
                        const hoveredLink = findLinkAtPosition(node.text, relativeX, relativeY);
                        canvas.style.cursor = hoveredLink ? 'pointer' : 'default';
                    }
                } else {
                    canvas.style.cursor = 'default';
                }
                
                if (state.connecting) {
                    state.dragStart = { x: pos.x, y: pos.y };
                    requestRedraw();
                    return;
                }
                
                if (state.isDragging && state.draggingNodeId) {
                    const node = findNodeById(state.draggingNodeId);
                    if (node) {
                        node.x += dx / state.zoom;
                        node.y += dy / state.zoom;
                        requestRedraw();
                    }
                } else if (state.isPanning) {
                    state.pan.x += dx;
                    state.pan.y += dy;
                    requestRedraw();
                }
                
                state.dragStart = { x: pos.x, y: pos.y };
            };
            
            const onMouseUp = () => {
                if (state.isDragging) saveState();
                if (state.isPanning) saveToLocalStorage();
                
                state.isDragging = false;
                state.isPanning = false;
                state.draggingNodeId = null;
            };
            
            const onWheel = (e) => {
                e.preventDefault();
                const pos = getMousePos(e);
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                zoom(zoomFactor, pos);
            };
            
            const onDoubleClick = (e) => {
                const pos = getMousePos(e);
                const clickedNodeId = findNodeAt(pos.x, pos.y);
                if (clickedNodeId) {
                    startEditingNode(clickedNodeId);
                }
            };
            
            const onKeyDown = (e) => {
                if (state.editingNodeId) return;
                
                if (e.key === 'Escape' && state.connecting) {
                    state.connecting = false;
                    requestRedraw();
                }
                
                if (e.key === 'n' && !e.ctrlKey && !e.metaKey) dom.addNodeBtn.click();
                if (e.key === 'f' && !e.ctrlKey && !e.metaKey) fitView();
                if (e.key === 'm' && !e.ctrlKey && !e.metaKey) toggleMarkdown();
                if (e.key === 't' && !e.ctrlKey && !e.metaKey) toggleTheme();
                
                if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                    e.preventDefault();
                    dom.fileInput.click();
                }
                
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (state.selectedNodeId) {
                        deleteNode(state.selectedNodeId);
                        state.selectedNodeId = null;
                        saveState();
                        requestRedraw();
                        showNotification('Node deleted', 'info');
                    }
                }
                
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    undo();
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                    e.preventDefault();
                    redo();
                }
                
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    exportAsRXT();
                    showNotification('Mind map exported', 'success');
                }
            };
            
            const onContextMenu = (e) => {
                e.preventDefault();
                const pos = getMousePos(e);
                const nodeId = findNodeAt(pos.x, pos.y);
                state.selectedNodeId = nodeId;
                requestRedraw();
                showContextMenu(e.clientX, e.clientY, nodeId);
            };
            
            // --- UI & Menus ---
            const showContextMenu = (x, y, nodeId) => {
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.classList.remove('hidden');
                
                const menuAddNode = document.getElementById('menu-add-node');
                const menuAddChild = document.getElementById('menu-add-child');
                const menuConnect = document.getElementById('menu-connect');
                const menuDeleteNode = document.getElementById('menu-delete-node');
                const menuDisconnect = document.getElementById('menu-disconnect');
                
                menuAddNode.style.display = 'block';
                menuAddNode.onclick = () => {
                    const pos = screenToWorld(x, y);
                    const newNode = createNode(pos.x, pos.y);
                    state.selectedNodeId = newNode.id;
                    saveState();
                    requestRedraw();
                    startEditingNode(newNode.id);
                };
                
                if (nodeId) {
                    menuAddChild.style.display = 'block';
                    menuConnect.style.display = 'block';
                    menuDeleteNode.style.display = 'block';
                    
                    const node = findNodeById(nodeId);
                    menuDisconnect.style.display = node.parentId ? 'block' : 'none';
                    
                    menuAddChild.onclick = () => {
                        const parent = findNodeById(nodeId);
                        const child = createNode(parent.x + parent.width + 50, parent.y, 'New Child', nodeId);
                        saveState();
                        startEditingNode(child.id);
                    };
                    
                    menuConnect.onclick = () => {
                        state.connecting = true;
                        showNotification('Click on another node to connect', 'info');
                    };
                    
                    menuDeleteNode.onclick = () => {
                        deleteNode(nodeId);
                        state.selectedNodeId = null;
                        saveState();
                        requestRedraw();
                        showNotification('Node deleted', 'info');
                    };
                    
                    menuDisconnect.onclick = () => {
                        node.parentId = null;
                        saveState();
                        requestRedraw();
                        showNotification('Node disconnected', 'info');
                    };
                } else {
                    menuAddChild.style.display = 'none';
                    menuConnect.style.display = 'none';
                    menuDeleteNode.style.display = 'none';
                    menuDisconnect.style.display = 'none';
                }
            };
            
            const hideContextMenu = () => contextMenu.classList.add('hidden');
            
            const importRXT = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        state.nodes = data.nodes || [];
                        state.nextNodeId = data.metadata?.nextNodeId || 1;
                        
                        if (data.settings) {
                            state.zoom = data.settings.zoom || 1;
                            state.pan = data.settings.pan || { x: 0, y: 0 };
                            
                            if (data.settings.theme) {
                                const isDark = data.settings.theme === 'dark';
                                document.documentElement.classList.toggle('dark', isDark);
                                dom.themeIconLight.classList.toggle('hidden', isDark);
                                dom.themeIconDark.classList.toggle('hidden', !isDark);
                            }
                        }
                        
                        state.selectedNodeId = null;
                        dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                        saveState();
                        requestRedraw();
                        showNotification('Mind map imported successfully', 'success');
                    } catch (error) {
                        console.error('Import error:', error);
                        showNotification('Invalid file format', 'error');
                    }
                };
                
                reader.readAsText(file);
                e.target.value = '';
            };
            
            const exportAsRXT = () => {
                const now = new Date();
                const timestamp = `${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                
                const exportData = {
                    timestamp: now.toISOString(),
                    settings: {
                        zoom: state.zoom,
                        pan: state.pan,
                        theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light'
                    },
                    nodes: state.nodes,
                    preview: {
                        canvasWidth: canvas.clientWidth,
                        canvasHeight: canvas.clientHeight,
                        nodeCount: state.nodes.length
                    },
                    metadata: {
                        nextNodeId: state.nextNodeId,
                        selectedNodeId: state.selectedNodeId,
                        version: '1.0'
                    }
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap-${timestamp}.rxt`;
                a.click();
                URL.revokeObjectURL(url);
            };
            
            const toggleTheme = () => {
                document.documentElement.classList.toggle('dark');
                const isDark = document.documentElement.classList.contains('dark');
                dom.themeIconLight.classList.toggle('hidden', isDark);
                dom.themeIconDark.classList.toggle('hidden', !isDark);
                localStorage.setItem('mindmap-theme', isDark ? 'dark' : 'light');
                requestRedraw();
            };
            
            const toggleMarkdown = () => {
                state.markdownMode = !state.markdownMode;
                dom.markdownIconOff.classList.toggle('hidden', state.markdownMode);
                dom.markdownIconOn.classList.toggle('hidden', !state.markdownMode);
                localStorage.setItem('mindmap-markdown', state.markdownMode ? 'on' : 'off');
                saveToLocalStorage();
                requestRedraw();
                
                showNotification(`Markdown mode ${state.markdownMode ? 'enabled' : 'disabled'}`, 'info');
            };
            
            // --- Image Handling ---
            const imageCache = new Map();
            
            const loadImage = (url) => {
                if (imageCache.has(url)) {
                    return imageCache.get(url);
                }
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => requestRedraw();
                img.onerror = () => {
                    console.error(`Failed to load image: ${url}`);
                    imageCache.delete(url);
                };
                img.src = url;
                imageCache.set(url, img);
                return img;
            };
            
            // --- Link Detection ---
            const findLinkAtPosition = (text, x, y) => {
                const parts = parseMarkdown(text);
                let currentX = 0;
                let currentY = FONT_SIZE * 0.8;
                const lineHeight = FONT_SIZE * LINE_HEIGHT;
                let currentLineHeight = lineHeight;
                
                ctx.font = `500 ${FONT_SIZE}px sans-serif`;
                
                for (const part of parts) {
                    if (part.text === '\n') {
                        currentY += currentLineHeight;
                        currentX = 0;
                        currentLineHeight = lineHeight;
                        continue;
                    }
                    
                    if (part.image) {
                        const maxWidth = 150;
                        const maxHeight = 100;
                        currentX += maxWidth + 5;
                        currentLineHeight = Math.max(currentLineHeight, maxHeight + 10);
                        continue;
                    }
                    
                    if (part.link) {
                        const textWidth = ctx.measureText(part.text).width;
                        if (x >= currentX && x <= currentX + textWidth && 
                            y >= currentY - FONT_SIZE * 0.2 && y <= currentY + FONT_SIZE * 0.8) {
                            return part.link;
                        }
                    }
                    
                    currentX += ctx.measureText(part.text).width;
                }
                
                return null;
            };
            
            // --- Markdown Parsing and Rendering (Completely Rewritten) ---
            
            // Create a stateful parser for markdown
            class MarkdownParser {
                constructor(text) {
                    this.text = text;
                    this.pos = 0;
                    this.len = text.length;
                }
                
                // Get the current character
                current() {
                    return this.pos < this.len ? this.text[this.pos] : '';
                }
                
                // Look ahead at the next character
                lookahead(n = 1) {
                    return this.pos + n - 1 < this.len ? this.text[this.pos + n - 1] : '';
                }
                
                // Consume and return the current character
                consume() {
                    return this.pos < this.len ? this.text[this.pos++] : '';
                }
                
                // Check if we're at the end
                eof() {
                    return this.pos >= this.len;
                }
                
                // Check if the text at the current position matches the given string
                match(str) {
                    return this.text.substr(this.pos, str.length) === str;
                }
                
                // Skip whitespace
                skipWhitespace() {
                    while (!this.eof() && /\s/.test(this.current())) {
                        this.consume();
                    }
                }
                
                // Parse the entire text
                parse() {
                    const parts = [];
                    
                    while (!this.eof()) {
                        // Check for code blocks first
                        if (this.match('```')) {
                            parts.push(...this.parseCodeBlock());
                            continue;
                        }
                        
                        // Check for headings
                        if (this.current() === '#' && this.pos === 0 || (this.pos > 0 && this.text[this.pos - 1] === '\n')) {
                            parts.push(...this.parseHeading());
                            continue;
                        }
                        
                        // Check for blockquotes
                        if (this.current() === '>' && (this.pos === 0 || (this.pos > 0 && this.text[this.pos - 1] === '\n'))) {
                            parts.push(...this.parseBlockquote());
                            continue;
                        }
                        
                        // Check for horizontal rules
                        if (this.match('---') || this.match('***') || this.match('___')) {
                            parts.push(...this.parseHorizontalRule());
                            continue;
                        }
                        
                        // Check for lists
                        if (this.match('- ') || this.match('* ') || this.match('+ ') || /\d+\./.test(this.text.substr(this.pos, 10))) {
                            parts.push(...this.parseList());
                            continue;
                        }
                        
                        // Check for tables
                        if (this.current() === '|' && (this.pos === 0 || (this.pos > 0 && this.text[this.pos - 1] === '\n'))) {
                            parts.push(...this.parseTable());
                            continue;
                        }
                        
                        // Otherwise, parse inline elements
                        parts.push(...this.parseInline());
                        
                        // Handle newlines
                        if (this.current() === '\n') {
                            parts.push({ text: '\n' });
                            this.consume();
                        }
                    }
                    
                    return parts;
                }
                
                // Parse a code block
                parseCodeBlock() {
                    const parts = [];
                    
                    // Consume the opening ```
                    this.consume();
                    this.consume();
                    this.consume();
                    
                    // Find the closing ```
                    let codeContent = '';
                    while (!this.eof() && !this.match('```')) {
                        codeContent += this.consume();
                    }
                    
                    // Consume the closing ```
                    if (this.match('```')) {
                        this.consume();
                        this.consume();
                        this.consume();
                    }
                    
                    // Split the code content into lines
                    const lines = codeContent.split('\n');
                    lines.forEach((line, index) => {
                        parts.push({
                            text: line,
                            code: true
                        });
                        
                        if (index < lines.length - 1) {
                            parts.push({ text: '\n' });
                        }
                    });
                    
                    return parts;
                }
                
                // Parse a heading
                parseHeading() {
                    const parts = [];
                    
                    // Count the number of #
                    let level = 0;
                    while (this.current() === '#' && level < 6) {
                        this.consume();
                        level++;
                    }
                    
                    // Skip whitespace after the #
                    this.skipWhitespace();
                    
                    // Parse the heading content (which can contain inline markdown)
                    const content = this.parseUntil('\n');
                    const contentParts = this.parseInlineMarkdown(content);
                    
                    // Add the heading parts with the heading level
                    contentParts.forEach(part => {
                        parts.push({
                            ...part,
                            heading: level
                        });
                    });
                    
                    // Add the newline
                    parts.push({ text: '\n' });
                    
                    return parts;
                }
                
                // Parse a blockquote
                parseBlockquote() {
                    const parts = [];
                    
                    // Consume the >
                    this.consume();
                    
                    // Skip whitespace after the >
                    this.skipWhitespace();
                    
                    // Parse the blockquote content (which can contain inline markdown)
                    const content = this.parseUntil('\n');
                    const contentParts = this.parseInlineMarkdown(content);
                    
                    // Add the blockquote parts
                    contentParts.forEach(part => {
                        parts.push({
                            ...part,
                            blockquote: true
                        });
                    });
                    
                    // Add the newline
                    parts.push({ text: '\n' });
                    
                    return parts;
                }
                
                // Parse a horizontal rule
                parseHorizontalRule() {
                    const parts = [];
                    
                    // Consume the horizontal rule
                    if (this.match('---')) {
                        this.consume();
                        this.consume();
                        this.consume();
                    } else if (this.match('***')) {
                        this.consume();
                        this.consume();
                        this.consume();
                    } else if (this.match('___')) {
                        this.consume();
                        this.consume();
                        this.consume();
                    }
                    
                    // Add the horizontal rule
                    parts.push({
                        text: '───────────────',
                        hr: true
                    });
                    
                    // Add the newline
                    parts.push({ text: '\n' });
                    
                    return parts;
                }
                
                // Parse a list
                parseList() {
                    const parts = [];
                    
                    // Check if it's an ordered list
                    const ordered = /\d+\./.test(this.text.substr(this.pos, 10));
                    
                    // Check if it's a task list
                    const task = this.match('- [ ] ') || this.match('- [x] ') || this.match('- [X] ');
                    const checked = this.match('- [x] ') || this.match('- [X] ');
                    
                    // Consume the list marker
                    if (ordered) {
                        while (/\d/.test(this.current())) {
                            this.consume();
                        }
                        this.consume(); // .
                        this.consume(); // space
                    } else if (task) {
                        this.consume(); // -
                        this.consume(); // space
                        this.consume(); // [
                        this.consume(); //  or x
                        this.consume(); // ]
                        this.consume(); // space
                    } else {
                        this.consume(); // - * or +
                        this.consume(); // space
                    }
                    
                    // Parse the list content (which can contain inline markdown)
                    const content = this.parseUntil('\n');
                    const contentParts = this.parseInlineMarkdown(content);
                    
                    // Add the list parts
                    const prefix = ordered ? '1. ' : (task ? (checked ? '☑ ' : '☐ ') : '• ');
                    parts.push({
                        text: prefix,
                        list: true,
                        ordered,
                        task,
                        checked
                    });
                    
                    contentParts.forEach(part => {
                        parts.push({
                            ...part,
                            list: true,
                            ordered,
                            task,
                            checked
                        });
                    });
                    
                    // Add the newline
                    parts.push({ text: '\n' });
                    
                    return parts;
                }
                
                // Parse a table
                parseTable() {
                    const parts = [];
                    
                    // Parse the table header
                    let headerLine = '';
                    while (!this.eof() && this.current() !== '\n') {
                        headerLine += this.consume();
                    }
                    
                    // Parse the separator line
                    this.consume(); // \n
                    let separatorLine = '';
                    while (!this.eof() && this.current() !== '\n') {
                        separatorLine += this.consume();
                    }
                    
                    // Parse the table rows
                    const rows = [];
                    while (!this.eof() && this.current() === '\n') {
                        this.consume(); // \n
                        
                        if (this.current() !== '|') {
                            break;
                        }
                        
                        let rowLine = '';
                        while (!this.eof() && this.current() !== '\n') {
                            rowLine += this.consume();
                        }
                        rows.push(rowLine);
                    }
                    
                    // Add the table parts
                    parts.push({
                        text: headerLine,
                        table: true
                    });
                    
                    parts.push({ text: '\n' });
                    
                    parts.push({
                        text: separatorLine,
                        table: true
                    });
                    
                    rows.forEach((row, index) => {
                        parts.push({ text: '\n' });
                        parts.push({
                            text: row,
                            table: true
                        });
                    });
                    
                    parts.push({ text: '\n' });
                    
                    return parts;
                }
                
                // Parse inline markdown elements
                parseInline() {
                    const content = this.parseUntil('\n');
                    return this.parseInlineMarkdown(content);
                }
                
                // Parse until a specific character
                parseUntil(char) {
                    let content = '';
                    while (!this.eof() && this.current() !== char) {
                        content += this.consume();
                    }
                    return content;
                }
                
                // Parse inline markdown elements in a string
                parseInlineMarkdown(text) {
                    const parts = [];
                    let i = 0;
                    
                    while (i < text.length) {
                        // Check for links [text](url)
                        if (text.substr(i, 1) === '[') {
                            const linkMatch = text.substr(i).match(/^\[([^\]]+)\]\(([^)]+)\)/);
                            if (linkMatch) {
                                parts.push({
                                    text: linkMatch[1],
                                    link: linkMatch[2]
                                });
                                i += linkMatch[0].length;
                                continue;
                            }
                        }
                        
                        // Check for images ![alt](url)
                        if (text.substr(i, 2) === '![') {
                            const imageMatch = text.substr(i).match(/^!\[([^\]]*)\]\(([^)]+)\)/);
                            if (imageMatch) {
                                parts.push({
                                    text: '',
                                    image: imageMatch[2],
                                    alt: imageMatch[1]
                                });
                                i += imageMatch[0].length;
                                continue;
                            }
                        }
                        
                        // Check for bold and italic ***text***
                        if (text.substr(i, 3) === '***') {
                            const endPos = text.indexOf('***', i + 3);
                            if (endPos !== -1) {
                                const content = text.substring(i + 3, endPos);
                                const contentParts = this.parseInlineMarkdown(content);
                                
                                contentParts.forEach(part => {
                                    parts.push({
                                        ...part,
                                        bold: true,
                                        italic: true
                                    });
                                });
                                
                                i = endPos + 3;
                                continue;
                            }
                        }
                        
                        // Check for bold **text**
                        if (text.substr(i, 2) === '**') {
                            const endPos = text.indexOf('**', i + 2);
                            if (endPos !== -1) {
                                const content = text.substring(i + 2, endPos);
                                const contentParts = this.parseInlineMarkdown(content);
                                
                                contentParts.forEach(part => {
                                    parts.push({
                                        ...part,
                                        bold: true
                                    });
                                });
                                
                                i = endPos + 2;
                                continue;
                            }
                        }
                        
                        // Check for italic *text* or _text_
                        if ((text.substr(i, 1) === '*' || text.substr(i, 1) === '_') && 
                            (i === 0 || text[i-1] !== text[i]) && 
                            (i === text.length - 1 || text[i+1] !== text[i])) {
                            
                            const marker = text[i];
                            const endPos = text.indexOf(marker, i + 1);
                            if (endPos !== -1) {
                                const content = text.substring(i + 1, endPos);
                                const contentParts = this.parseInlineMarkdown(content);
                                
                                contentParts.forEach(part => {
                                    parts.push({
                                        ...part,
                                        italic: true
                                    });
                                });
                                
                                i = endPos + 1;
                                continue;
                            }
                        }
                        
                        // Check for strikethrough ~~text~~
                        if (text.substr(i, 2) === '~~') {
                            const endPos = text.indexOf('~~', i + 2);
                            if (endPos !== -1) {
                                const content = text.substring(i + 2, endPos);
                                const contentParts = this.parseInlineMarkdown(content);
                                
                                contentParts.forEach(part => {
                                    parts.push({
                                        ...part,
                                        strikethrough: true
                                    });
                                });
                                
                                i = endPos + 2;
                                continue;
                            }
                        }
                        
                        // Check for inline code `text`
                        if (text.substr(i, 1) === '`') {
                            const endPos = text.indexOf('`', i + 1);
                            if (endPos !== -1) {
                                const content = text.substring(i + 1, endPos);
                                parts.push({
                                    text: content,
                                    code: true
                                });
                                i = endPos + 1;
                                continue;
                            }
                        }
                        
                        // Regular text
                        parts.push({
                            text: text[i]
                        });
                        i++;
                    }
                    
                    return parts;
                }
            }
            
            // Parse markdown text into parts
            const parseMarkdown = (text) => {
                const parser = new MarkdownParser(text);
                const parts = parser.parse();
                
                // Normalize the parts
                return parts.map(part => ({
                    text: part.text || '',
                    bold: !!part.bold,
                    italic: !!part.italic,
                    code: !!part.code,
                    strikethrough: !!part.strikethrough,
                    blockquote: !!part.blockquote,
                    link: part.link || null,
                    image: part.image || null,
                    alt: part.alt || '',
                    heading: part.heading || null,
                    list: !!part.list,
                    ordered: !!part.ordered,
                    task: !!part.task,
                    checked: !!part.checked,
                    hr: !!part.hr,
                    table: !!part.table
                }));
            };
            
            const renderMarkdownText = (ctx, text, x, y) => {
                const parts = parseMarkdown(text);
                let currentX = x;
                let currentY = y + FONT_SIZE * 0.8;
                const lineHeight = FONT_SIZE * LINE_HEIGHT;
                let currentLineHeight = lineHeight;
                
                parts.forEach(part => {
                    if (part.text === '\n') {
                        currentY += currentLineHeight;
                        currentX = x;
                        currentLineHeight = lineHeight;
                        return;
                    }
                    
                    // Handle images
                    if (part.image) {
                        const img = loadImage(part.image);
                        if (img.complete && img.naturalWidth > 0) {
                            const maxWidth = 150;
                            const maxHeight = 100;
                            let { width, height } = img;
                            
                            if (width > maxWidth) {
                                height = (height * maxWidth) / width;
                                width = maxWidth;
                            }
                            if (height > maxHeight) {
                                width = (width * maxHeight) / height;
                                height = maxHeight;
                            }
                            
                            ctx.drawImage(img, currentX, currentY, width, height);
                            currentX += width + 5; // Add small spacing between inline images
                            currentLineHeight = Math.max(currentLineHeight, height + 10); // Adjust line height for images
                        }
                        return;
                    }
                    
                    ctx.save();
                    ctx.fillStyle = getCssVar('--node-text');
                    
                    // Handle headings
                    if (part.heading) {
                        const headingSizes = [24, 20, 18, 16, 14, 12];
                        const headingSize = headingSizes[part.heading - 1] || 12;
                        ctx.font = `700 ${headingSize}px sans-serif`;
                        ctx.fillStyle = getCssVar('--node-text');
                    }
                    // Handle regular formatting
                    else {
                        let fontWeight = '500';
                        let fontStyle = '';
                        
                        if (part.bold && part.italic) {
                            fontWeight = '700';
                            fontStyle = 'italic ';
                        } else if (part.bold) {
                            fontWeight = '700';
                        } else if (part.italic) {
                            fontStyle = 'italic ';
                        }
                        
                        ctx.font = `${fontStyle}${fontWeight} ${FONT_SIZE}px sans-serif`;
                        
                        if (part.code) {
                            ctx.font = `500 ${FONT_SIZE}px monospace`;
                            ctx.fillStyle = getCssVar('--success');
                        }
                        if (part.link) {
                            ctx.fillStyle = getCssVar('--info');
                            ctx.textDecoration = 'underline';
                        }
                        if (part.blockquote) {
                            ctx.fillStyle = getCssVar('--warning');
                        }
                        if (part.hr) {
                            ctx.fillStyle = getCssVar('--border');
                        }
                        if (part.table) {
                            ctx.fillStyle = getCssVar('--text-primary');
                        }
                    }
                    
                    ctx.fillText(part.text, currentX, currentY);
                    
                    // Handle strikethrough
                    if (part.strikethrough) {
                        const width = ctx.measureText(part.text).width;
                        ctx.strokeStyle = getCssVar('--danger');
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(currentX, currentY - FONT_SIZE * 0.1);
                        ctx.lineTo(currentX + width, currentY - FONT_SIZE * 0.1);
                        ctx.stroke();
                    }
                    
                    // Reset text decoration
                    if (part.link) {
                        ctx.textDecoration = 'none';
                    }
                    
                    currentX += ctx.measureText(part.text).width;
                    ctx.restore();
                });
            };
            
            const measureMarkdownText = (ctx, text) => {
                const parts = parseMarkdown(text);
                let maxWidth = 0;
                let totalHeight = 0;
                let currentLineWidth = 0;
                let currentLineHeight = FONT_SIZE * LINE_HEIGHT;
                const lineHeight = FONT_SIZE * LINE_HEIGHT;
                
                parts.forEach(part => {
                    if (part.text === '\n') {
                        maxWidth = Math.max(maxWidth, currentLineWidth);
                        currentLineWidth = 0;
                        totalHeight += currentLineHeight;
                        currentLineHeight = lineHeight;
                        return;
                    }
                    
                    // Handle images
                    if (part.image) {
                        maxWidth = Math.max(maxWidth, currentLineWidth, 150); // Image width
                        currentLineWidth = 0; // Reset for next content
                        currentLineHeight = Math.max(currentLineHeight, 110); // Image height + padding
                        return;
                    }
                    
                    ctx.save();
                    
                    // Handle headings
                    if (part.heading) {
                        const headingSizes = [24, 20, 18, 16, 14, 12];
                        const headingSize = headingSizes[part.heading - 1] || 12;
                        ctx.font = `700 ${headingSize}px sans-serif`;
                    }
                    // Handle regular formatting
                    else {
                        let fontWeight = '500';
                        let fontStyle = '';
                        
                        if (part.bold && part.italic) {
                            fontWeight = '700';
                            fontStyle = 'italic ';
                        } else if (part.bold) {
                            fontWeight = '700';
                        } else if (part.italic) {
                            fontStyle = 'italic ';
                        }
                        
                        if (part.code) {
                            ctx.font = `500 ${FONT_SIZE}px monospace`;
                        } else {
                            ctx.font = `${fontStyle}${fontWeight} ${FONT_SIZE}px sans-serif`;
                        }
                    }
                    
                    currentLineWidth += ctx.measureText(part.text).width;
                    ctx.restore();
                });
                
                maxWidth = Math.max(maxWidth, currentLineWidth, 80);
                totalHeight = totalHeight + currentLineHeight;
                
                return { width: maxWidth, height: totalHeight };
            };
            
            // --- Actions ---
            const zoom = (factor, pivot = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 }) => {
                const newZoom = Math.max(0.1, Math.min(5, state.zoom * factor));
                const worldPos = screenToWorld(pivot.x, pivot.y);
                
                state.pan.x = pivot.x - worldPos.x * newZoom;
                state.pan.y = pivot.y - worldPos.y * newZoom;
                state.zoom = newZoom;
                
                dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                saveToLocalStorage();
                requestRedraw();
            };
            
            const fitView = () => {
                if (state.nodes.length === 0) return;
                
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                state.nodes.forEach(n => {
                    minX = Math.min(minX, n.x);
                    minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x + n.width);
                    maxY = Math.max(maxY, n.y + n.height);
                });
                
                const padding = 50;
                const contentWidth = maxX - minX;
                const contentHeight = maxY - minY;
                
                const scaleX = (canvas.clientWidth - padding * 2) / contentWidth;
                const scaleY = (canvas.clientHeight - padding * 2) / contentHeight;
                state.zoom = Math.min(scaleX, scaleY, 1);
                
                const centerX = minX + contentWidth / 2;
                const centerY = minY + contentHeight / 2;
                state.pan.x = canvas.clientWidth / 2 - centerX * state.zoom;
                state.pan.y = canvas.clientHeight / 2 - centerY * state.zoom;
                
                dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                saveToLocalStorage();
                requestRedraw();
            };
            
            // --- Helpers ---
            const getMousePos = (e) => ({ 
                x: e.clientX, 
                y: e.clientY - dom.addNodeBtn.closest('header').offsetHeight 
            });
            
            const screenToWorld = (x, y) => ({ 
                x: (x - state.pan.x) / state.zoom, 
                y: (y - state.pan.y) / state.zoom 
            });
            
            const worldToScreen = (x, y) => ({ 
                x: x * state.zoom + state.pan.x, 
                y: y * state.zoom + state.pan.y 
            });
            
            const findNodeById = (id) => state.nodes.find(n => n.id === id);
            
            const findNodeAt = (x, y) => {
                const worldPos = screenToWorld(x, y);
                return state.nodes.slice().reverse().find(n => 
                    worldPos.x >= n.x && worldPos.x <= n.x + n.width &&
                    worldPos.y >= n.y && worldPos.y <= n.y + n.height
                )?.id || null;
            };
            
            const getCssVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            
            const fillRoundedRect = (c, x, y, w, h, r) => {
                c.beginPath(); 
                c.moveTo(x+r, y); 
                c.arcTo(x+w, y, x+w, y+h, r); 
                c.arcTo(x+w, y+h, x, y+h, r); 
                c.arcTo(x, y+h, x, y, r); 
                c.arcTo(x, y, x+w, y, r); 
                c.closePath(); 
                c.fill();
            };
            
            const strokeRoundedRect = (c, x, y, w, h, r) => {
                c.beginPath(); 
                c.moveTo(x+r, y); 
                c.arcTo(x+w, y, x+w, y+h, r); 
                c.arcTo(x+w, y+h, x, y+h, r); 
                c.arcTo(x, y+h, x, y, r); 
                c.arcTo(x, y, x+w, y, r); 
                c.closePath(); 
                c.stroke();
            };
            
            // --- Initialization ---
            const init = () => {
                // Set up theme
                const savedTheme = localStorage.getItem('mindmap-theme');
                if (savedTheme === 'light') {
                    document.documentElement.classList.remove('dark');
                } else {
                    document.documentElement.classList.add('dark');
                }
                
                // Update theme icons
                const isDark = document.documentElement.classList.contains('dark');
                dom.themeIconLight.classList.toggle('hidden', isDark);
                dom.themeIconDark.classList.toggle('hidden', !isDark);
                
                // Set up markdown mode
                const savedMarkdown = localStorage.getItem('mindmap-markdown');
                if (savedMarkdown === 'off') {
                    state.markdownMode = false;
                } else {
                    state.markdownMode = true;
                }
                
                dom.markdownIconOff.classList.toggle('hidden', state.markdownMode);
                dom.markdownIconOn.classList.toggle('hidden', !state.markdownMode);
                
                // Set up event listeners
                setupEventListeners();
                
                // Resize canvas
                resizeCanvas();
                
                // Load saved data or create welcome map
                const hasLoadedData = loadFromLocalStorage();
                if (!hasLoadedData) {
                    const cX = canvas.clientWidth / 2;
                    const cY = canvas.clientHeight / 2;
                    createNode(
                        screenToWorld(cX, cY).x - 50, 
                        screenToWorld(cX, cY).y - 25, 
                        '# Welcome to Mind Map!\n\nThis is a **markdown-enabled** mind map.\n\n## Features\n- *Rich text formatting*\n- ~~Strikethrough text~~\n- `Inline code`\n- [Links](https://example.com)\n- Images: ![Example](https://picsum.photos/seed/mindmap/150/100.jpg)\n- Tables\n- Lists\n- And much more!\n\n### _Complex Formatting_\n\nThis demonstrates **nested** *formatting* like **_bold and italic_** and ~~strikethrough with *italic*~~.\n\n> _Blockquote with italic text_'
                    );
                }
                
                // Update UI to reflect loaded state
                dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                
                // Set up auto-save
                setupAutoSave();
                
                // Save initial state
                saveState();
                
                // Fit to view if no data was loaded
                if (!hasLoadedData) {
                    fitView();
                }
                
                // Initial render
                requestRedraw();
                
                // Show welcome notification if no data was loaded
                if (!hasLoadedData) {
                    showNotification('Welcome to Mind Map! Double-click a node to edit it.', 'info', 5000);
                }
            };
            
            // Initialize the application
            init();
        });
    </script>
</body>
</html>
