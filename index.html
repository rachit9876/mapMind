<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg: #ffffff;
            --bg-secondary: #f9fafb;
            --border: #e5e7eb;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --accent: #4f46e5;
            --accent-hover: #4338ca;
            --node-bg: #ffffff;
            --node-border: #d1d5db;
            --node-text: #1f2937;
            --node-shadow: rgba(0,0,0,0.05);
            --line: #9ca3af;
            --dot: #e5e7eb;
        }
        html.dark {
            --bg: #111827;
            --bg-secondary: #1f2937;
            --border: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --node-bg: #1f2937;
            --node-border: #4b5563;
            --node-text: #f9fafb;
            --node-shadow: rgba(0,0,0,0.2);
            --line: #6b7280;
            --dot: #374151;
        }
        body {
            background-color: var(--bg);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .dot-background {
            background-image: none;
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        .btn-secondary {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover {
            background-color: var(--border);
        }
        .btn-primary {
            background-color: var(--accent);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
        }
        #context-menu {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
        }
        #context-menu li:hover {
            background-color: var(--accent);
            color: white;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="flex flex-col h-screen">

    <header class="bg-[var(--bg-secondary)]/80 backdrop-blur-xl border-b border-[var(--border)] p-2 flex justify-between items-center z-20">
        <div class="flex items-center gap-2">
            <h1 class="text-xl font-bold">Mind Map</h1>
        </div>
        
        <div class="absolute left-1/2 -translate-x-1/2 flex items-center gap-2 p-1 bg-[var(--bg)] border border-[var(--border)] rounded-lg">
            <button id="undoBtn" class="btn btn-secondary" title="Undo (Ctrl+Z)" disabled>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 15l-3-3m0 0l3-3m-3 3h8a5 5 0 0 0 0-10H9"></path></svg>
            </button>
            <button id="redoBtn" class="btn btn-secondary" title="Redo (Ctrl+Y)" disabled>
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 15l3-3m0 0l-3-3m3 3H8a5 5 0 0 0 0 10h3"></path></svg>
            </button>
            <div class="w-px h-6 bg-[var(--border)] mx-1"></div>
            <button id="addNodeBtn" class="btn btn-primary" title="Add Node (N)">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
            </button>
        </div>

        <div class="flex items-center gap-2">
            <div class="flex items-center gap-1 p-1 bg-[var(--bg)] border border-[var(--border)] rounded-lg">
                <button id="zoomOutBtn" class="btn btn-secondary" title="Zoom Out (-)">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path></svg>
                </button>
                <div id="zoomIndicator" class="text-sm font-semibold w-16 text-center">100%</div>
                <button id="zoomInBtn" class="btn btn-secondary" title="Zoom In (+)">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                </button>
            </div>
            <button id="fitViewBtn" class="btn btn-secondary" title="Fit to View (F)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4h4m12 4V4h-4M4 16v4h4m12-4v4h-4"></path></svg>
            </button>
            <button id="importBtn" class="btn btn-secondary" title="Import">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-1m-4-8l4 4m0 0l4-4m-4 4V4"></path></svg>
            </button>
            <button id="exportBtn" class="btn btn-secondary" title="Export">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
            </button>
            <button id="markdownToggle" class="btn btn-secondary" title="Toggle Markdown Mode (M)">
                <svg id="markdown-icon-off" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                <svg id="markdown-icon-on" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M22.269 19.385c-.13-.151-.297-.243-.485-.243h-3.039v-7.874l-2.255 2.885-.239.307-.238-.307-2.255-2.885v7.874h-3.04c-.187 0-.354.092-.485.243-.13.15-.202.35-.202.56 0 .21.072.41.202.56.131.151.298.243.485.243h3.04v1.125c0 .621.504 1.125 1.125 1.125s1.125-.504 1.125-1.125v-1.125h3.039c.187 0 .354-.092.485-.243.13-.15.202-.35.202-.56 0-.21-.072-.41-.202-.56zm-9.269-9.385h-3v7h-2l3 3 3-3h-2v-7h1z"/></svg>
            </button>
            <button id="themeToggle" class="btn btn-secondary" title="Toggle Theme (T)">
                <svg id="theme-icon-light" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0z"></path></svg>
                <svg id="theme-icon-dark" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 0 1 8.646 3.646 9.003 9.003 0 0 0 12 21a9.003 9.003 0 0 0 8.354-5.646z"></path></svg>
            </button>
        </div>
    </header>

    <main class="flex-1 dot-background relative">
        <canvas id="mindMapCanvas"></canvas>
        <textarea id="node-editor" class="absolute hidden text-left outline-none bg-transparent border-none text-[var(--node-text)] rounded-lg p-2 z-10 resize-none overflow-hidden" rows="1" wrap="off"></textarea>
    </main>

    <div id="context-menu" class="absolute hidden z-30 rounded-lg shadow-lg w-48">
        <ul class="py-1">
            <li id="menu-add-child" class="px-4 py-2 cursor-pointer">Add Child</li>
            <li id="menu-add-node" class="px-4 py-2 cursor-pointer">Add Node</li>
            <li id="menu-connect" class="px-4 py-2 cursor-pointer">Connect</li>
            <li id="menu-delete-node" class="px-4 py-2 cursor-pointer">Delete Node</li>
            <li id="menu-disconnect" class="px-4 py-2 cursor-pointer">Disconnect</li>
        </ul>
    </div>
    
    <input type="file" id="file-input" class="hidden" accept=".rxt">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mindMapCanvas');
            const ctx = canvas.getContext('2d');
            const nodeEditor = document.getElementById('node-editor');
            const contextMenu = document.getElementById('context-menu');

            let state = {
                nodes: [],
                pan: { x: 0, y: 0 },
                zoom: 1,
                nextNodeId: 1,
                selectedNodeId: null,
                editingNodeId: null,
                draggingNodeId: null,
                dragStart: { x: 0, y: 0 },
                isDragging: false,
                isPanning: false,
                history: [],
                historyIndex: -1,
                connecting: false,
                markdownMode: false,
            };

            const dom = {
                undoBtn: document.getElementById('undoBtn'),
                redoBtn: document.getElementById('redoBtn'),
                addNodeBtn: document.getElementById('addNodeBtn'),
                zoomInBtn: document.getElementById('zoomInBtn'),
                zoomOutBtn: document.getElementById('zoomOutBtn'),
                zoomIndicator: document.getElementById('zoomIndicator'),
                fitViewBtn: document.getElementById('fitViewBtn'),
                importBtn: document.getElementById('importBtn'),
                exportBtn: document.getElementById('exportBtn'),
                markdownToggle: document.getElementById('markdownToggle'),
                markdownIconOff: document.getElementById('markdown-icon-off'),
                markdownIconOn: document.getElementById('markdown-icon-on'),
                themeToggle: document.getElementById('themeToggle'),
                themeIconLight: document.getElementById('theme-icon-light'),
                themeIconDark: document.getElementById('theme-icon-dark'),
                fileInput: document.getElementById('file-input'),
            };

            const FONT_SIZE = 16;
            const NODE_PADDING = 16;

            // --- Core Functions ---
            const resizeCanvas = () => {
                const header = document.querySelector('header');
                canvas.width = window.innerWidth * window.devicePixelRatio;
                canvas.height = (window.innerHeight - header.offsetHeight) * window.devicePixelRatio;
                canvas.style.width = `${window.innerWidth}px`;
                canvas.style.height = `${window.innerHeight - header.offsetHeight}px`;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                requestRedraw();
            };

            const requestRedraw = () => {
                requestAnimationFrame(draw);
            };

            const draw = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(state.pan.x, state.pan.y);
                ctx.scale(state.zoom, state.zoom);

                drawConnections();
                drawNodes();

                if (state.connecting && state.selectedNodeId) {
                    drawConnectionLineToCursor();
                }

                ctx.restore();
            };

            const drawNodes = () => {
                ctx.font = `500 ${FONT_SIZE}px Inter`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                for (const node of state.nodes) {
                    updateNodeDimensions(node);
                    
                    ctx.fillStyle = getCssVar('--node-bg');
                    ctx.strokeStyle = getCssVar(node.id === state.selectedNodeId ? '--accent' : '--node-border');
                    ctx.lineWidth = 2;
                    ctx.shadowColor = getCssVar('--node-shadow');
                    ctx.shadowBlur = 10;

                    fillRoundedRect(ctx, node.x, node.y, node.width, node.height, 8);
                    strokeRoundedRect(ctx, node.x, node.y, node.width, node.height, 8);
                    
                    ctx.shadowColor = 'transparent';
                    
                    ctx.shadowColor = 'transparent';
                    
                    if (node.id !== state.editingNodeId) {
                        ctx.fillStyle = getCssVar('--node-text');
                        if (state.markdownMode) {
                            renderMarkdownText(ctx, node.text, node.x + NODE_PADDING, node.y + NODE_PADDING);
                        } else {
                            const lines = node.text.split('\n');
                            const lineHeight = FONT_SIZE * 1.4;
                            const startY = node.y + node.height / 2 - ((lines.length - 1) * lineHeight) / 2;
                            lines.forEach((line, index) => {
                                ctx.fillText(line, node.x + NODE_PADDING, startY + index * lineHeight);
                            });
                        }
                    }
                }
            };

            const drawConnections = () => {
                ctx.strokeStyle = getCssVar('--line');
                ctx.lineWidth = 2.5;
                for (const node of state.nodes) {
                    if (node.parentId) {
                        const parent = findNodeById(node.parentId);
                        if (parent) {
                            const start = { x: parent.x + parent.width / 2, y: parent.y + parent.height / 2 };
                            const end = { x: node.x + node.width / 2, y: node.y + node.height / 2 };
                            
                            ctx.beginPath();
                            ctx.moveTo(start.x, start.y);
                            ctx.bezierCurveTo(start.x + 50, start.y, end.x - 50, end.y, end.x, end.y);
                            ctx.stroke();
                        }
                    }
                }
            };

            const drawConnectionLineToCursor = () => {
                const startNode = findNodeById(state.selectedNodeId);
                if (!startNode) return;

                const start = { x: startNode.x + startNode.width / 2, y: startNode.y + startNode.height / 2 };
                const end = screenToWorld(state.dragStart.x, state.dragStart.y);

                ctx.strokeStyle = getCssVar('--accent');
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
                ctx.setLineDash([]);
            };

            // --- State & History ---
            const saveState = () => {
                const snapshot = JSON.stringify({ nodes: state.nodes, nextNodeId: state.nextNodeId });
                state.historyIndex++;
                state.history = state.history.slice(0, state.historyIndex);
                state.history.push(snapshot);
                updateHistoryButtons();
            };

            const undo = () => {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    loadState(state.history[state.historyIndex]);
                }
            };

            const redo = () => {
                if (state.historyIndex < state.history.length - 1) {
                    state.historyIndex++;
                    loadState(state.history[state.historyIndex]);
                }
            };
            
            const loadState = (snapshot) => {
                const loaded = JSON.parse(snapshot);
                state.nodes = loaded.nodes;
                state.nextNodeId = loaded.nextNodeId;
                state.selectedNodeId = null;
                state.editingNodeId = null;
                hideNodeEditor();
                updateHistoryButtons();
                requestRedraw();
            };

            const updateHistoryButtons = () => {
                dom.undoBtn.disabled = state.historyIndex <= 0;
                dom.redoBtn.disabled = state.historyIndex >= state.history.length - 1;
            };

            // --- Node Management ---
            const createNode = (x, y, text = 'New Idea', parentId = null) => {
                const newNode = {
                    id: state.nextNodeId++,
                    text,
                    x, y,
                    width: 0, height: 0,
                    parentId,
                };
                updateNodeDimensions(newNode);
                state.nodes.push(newNode);
                return newNode;
            };

            const deleteNode = (nodeId) => {
                const children = state.nodes.filter(n => n.parentId === nodeId).map(n => n.id);
                children.forEach(deleteNode);
                state.nodes = state.nodes.filter(n => n.id !== nodeId);
            };

            const updateNodeDimensions = (node) => {
                ctx.font = `500 ${FONT_SIZE}px Inter`;
                if (state.markdownMode) {
                    const dimensions = measureMarkdownText(ctx, node.text);
                    node.width = dimensions.width + NODE_PADDING * 2;
                    node.height = dimensions.height + NODE_PADDING * 2;
                } else {
                    const lines = node.text.split('\n');
                    const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width), 80);
                    const lineHeight = FONT_SIZE * 1.4;
                    node.width = maxWidth + NODE_PADDING * 1.5;
                    node.height = lines.length * lineHeight + NODE_PADDING * 2;
                }
            };

            const updateEditorSize = () => {
                if (!state.editingNodeId) return;
                const node = findNodeById(state.editingNodeId);
                if (!node) return;
                
                const screenPos = worldToScreen(node.x, node.y);
                nodeEditor.style.left = `${screenPos.x}px`;
                nodeEditor.style.top = `${screenPos.y}px`;
                nodeEditor.style.width = `${node.width * state.zoom}px`;
                nodeEditor.style.height = `${node.height * state.zoom}px`;
            };

            const startEditingNode = (nodeId) => {
                const node = findNodeById(nodeId);
                if (!node) return;

                state.editingNodeId = nodeId;
                const screenPos = worldToScreen(node.x, node.y);
                
                nodeEditor.value = node.text;
                nodeEditor.style.fontSize = `${FONT_SIZE * state.zoom}px`;
                nodeEditor.style.padding = `${NODE_PADDING * state.zoom}px`;
                nodeEditor.style.lineHeight = `${FONT_SIZE * 1.4 * state.zoom}px`;
                nodeEditor.classList.remove('hidden');
                updateEditorSize();
                nodeEditor.focus();
                nodeEditor.select();
                requestRedraw();
            };

            const finishEditingNode = () => {
                if (!state.editingNodeId) return;
                const node = findNodeById(state.editingNodeId);
                if (node) {
                    node.text = nodeEditor.value;
                    saveState();
                }
                hideNodeEditor();
                requestRedraw();
            };
            
            const hideNodeEditor = () => {
                state.editingNodeId = null;
                nodeEditor.classList.add('hidden');
            };

            // --- Event Handlers ---
            const setupEventListeners = () => {
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
                canvas.addEventListener('mouseleave', onMouseUp);
                canvas.addEventListener('wheel', onWheel);
                canvas.addEventListener('dblclick', onDoubleClick);
                canvas.addEventListener('contextmenu', onContextMenu);

                nodeEditor.addEventListener('blur', finishEditingNode);
                nodeEditor.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        if (e.shiftKey) {
                            // Allow new line with Shift+Enter
                            setTimeout(() => {
                                autoResizeEditor();
                            }, 0);
                        } else {
                            e.preventDefault();
                            finishEditingNode();
                        }
                    }
                    if (e.key === 'Escape') hideNodeEditor();
                });
                
                nodeEditor.addEventListener('input', () => {
                    // Update node size in real-time
                    if (state.editingNodeId) {
                        const node = findNodeById(state.editingNodeId);
                        if (node) {
                            node.text = nodeEditor.value;
                            updateNodeDimensions(node);
                            updateEditorSize();
                            requestRedraw();
                        }
                    }
                });

                dom.addNodeBtn.addEventListener('click', () => {
                    const center = screenToWorld(canvas.clientWidth / 2, canvas.clientHeight / 2);
                    const newNode = createNode(center.x, center.y);
                    state.selectedNodeId = newNode.id;
                    saveState();
                    requestRedraw();
                    startEditingNode(newNode.id);
                });
                
                dom.zoomInBtn.addEventListener('click', () => zoom(1.2));
                dom.zoomOutBtn.addEventListener('click', () => zoom(0.8));
                dom.fitViewBtn.addEventListener('click', fitView);
                dom.undoBtn.addEventListener('click', undo);
                dom.redoBtn.addEventListener('click', redo);
                dom.markdownToggle.addEventListener('click', toggleMarkdown);
                dom.themeToggle.addEventListener('click', toggleTheme);
                dom.importBtn.addEventListener('click', () => dom.fileInput.click());
                dom.exportBtn.addEventListener('click', exportAsRXT);
                dom.fileInput.addEventListener('change', importRXT);

                window.addEventListener('resize', resizeCanvas);
                window.addEventListener('keydown', onKeyDown);
                document.addEventListener('click', () => hideContextMenu());
            };

            const onMouseDown = (e) => {
                if (e.button === 2) return; // Disable right-click drag
                
                hideContextMenu();
                finishEditingNode();
                const pos = getMousePos(e);
                const clickedNodeId = findNodeAt(pos.x, pos.y);

                if (state.connecting) {
                    if (clickedNodeId && clickedNodeId !== state.selectedNodeId) {
                        const child = findNodeById(clickedNodeId);
                        if (child) {
                            child.parentId = state.selectedNodeId;
                            saveState();
                        }
                    }
                    state.connecting = false;
                    requestRedraw();
                    return;
                }

                state.selectedNodeId = clickedNodeId;

                if (clickedNodeId) {
                    state.isDragging = true;
                    state.draggingNodeId = clickedNodeId;
                } else {
                    state.isPanning = true;
                }
                
                state.dragStart = { x: pos.x, y: pos.y };
                requestRedraw();
            };

            const onMouseMove = (e) => {
                const pos = getMousePos(e);
                const dx = (pos.x - state.dragStart.x);
                const dy = (pos.y - state.dragStart.y);

                if (state.connecting) {
                    state.dragStart = { x: pos.x, y: pos.y };
                    requestRedraw();
                    return;
                }

                if (state.isDragging && state.draggingNodeId) {
                    const node = findNodeById(state.draggingNodeId);
                    if (node) {
                        node.x += dx / state.zoom;
                        node.y += dy / state.zoom;
                        requestRedraw();
                    }
                } else if (state.isPanning) {
                    state.pan.x += dx;
                    state.pan.y += dy;
                    requestRedraw();
                }
                state.dragStart = { x: pos.x, y: pos.y };
            };

            const onMouseUp = () => {
                if (state.isDragging) saveState();
                state.isDragging = false;
                state.isPanning = false;
                state.draggingNodeId = null;
            };

            const onWheel = (e) => {
                e.preventDefault();
                const pos = getMousePos(e);
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                zoom(zoomFactor, pos);
            };

            const onDoubleClick = (e) => {
                const pos = getMousePos(e);
                const clickedNodeId = findNodeAt(pos.x, pos.y);
                if (clickedNodeId) {
                    startEditingNode(clickedNodeId);
                }
            };

            const onKeyDown = (e) => {
                if (state.editingNodeId) return;

                if (e.key === 'Escape' && state.connecting) {
                    state.connecting = false;
                    requestRedraw();
                }
                if (e.key === 'n') dom.addNodeBtn.click();
                if (e.key === 'f') fitView();
                if (e.key === 'm') toggleMarkdown();
                if (e.key === 't') toggleTheme();
                if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                    e.preventDefault();
                    dom.fileInput.click();
                }
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (state.selectedNodeId) {
                        deleteNode(state.selectedNodeId);
                        state.selectedNodeId = null;
                        saveState();
                        requestRedraw();
                    }
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') undo();
                if ((e.ctrlKey || e.metaKey) && e.key === 'y') redo();
            };

            const onContextMenu = (e) => {
                e.preventDefault();
                const pos = getMousePos(e);
                const nodeId = findNodeAt(pos.x, pos.y);
                state.selectedNodeId = nodeId;
                requestRedraw();
                showContextMenu(e.clientX, e.clientY, nodeId);
            };

            // --- UI & Menus ---
            const showContextMenu = (x, y, nodeId) => {
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.classList.remove('hidden');
                
                const menuAddNode = document.getElementById('menu-add-node');
                const menuAddChild = document.getElementById('menu-add-child');
                const menuConnect = document.getElementById('menu-connect');
                const menuDeleteNode = document.getElementById('menu-delete-node');
                const menuDisconnect = document.getElementById('menu-disconnect');

                menuAddNode.style.display = 'block';
                menuAddNode.onclick = () => {
                    const pos = screenToWorld(x, y);
                    const newNode = createNode(pos.x, pos.y);
                    state.selectedNodeId = newNode.id;
                    saveState();
                    requestRedraw();
                    startEditingNode(newNode.id);
                };

                if (nodeId) {
                    menuAddChild.style.display = 'block';
                    menuConnect.style.display = 'block';
                    menuDeleteNode.style.display = 'block';
                    const node = findNodeById(nodeId);
                    menuDisconnect.style.display = node.parentId ? 'block' : 'none';

                    menuAddChild.onclick = () => {
                        const parent = findNodeById(nodeId);
                        const child = createNode(parent.x + parent.width + 50, parent.y, 'New Child', nodeId);
                        saveState();
                        startEditingNode(child.id);
                    };
                    menuConnect.onclick = () => {
                        state.connecting = true;
                    };
                    menuDeleteNode.onclick = () => {
                        deleteNode(nodeId);
                        state.selectedNodeId = null;
                        saveState();
                        requestRedraw();
                    };
                    menuDisconnect.onclick = () => {
                        node.parentId = null;
                        saveState();
                        requestRedraw();
                    };
                } else {
                    menuAddChild.style.display = 'none';
                    menuConnect.style.display = 'none';
                    menuDeleteNode.style.display = 'none';
                    menuDisconnect.style.display = 'none';
                }
            };

            const hideContextMenu = () => contextMenu.classList.add('hidden');

            const importRXT = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        state.nodes = data.nodes || [];
                        state.nextNodeId = data.metadata?.nextNodeId || 1;
                        if (data.settings) {
                            state.zoom = data.settings.zoom || 1;
                            state.pan = data.settings.pan || { x: 0, y: 0 };
                            if (data.settings.theme) {
                                const isDark = data.settings.theme === 'dark';
                                document.documentElement.classList.toggle('dark', isDark);
                                dom.themeIconLight.classList.toggle('hidden', isDark);
                                dom.themeIconDark.classList.toggle('hidden', !isDark);
                            }
                        }
                        state.selectedNodeId = null;
                        dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                        saveState();
                        requestRedraw();
                    } catch (error) {
                        alert('Invalid file format');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            };

            const exportAsRXT = () => {
                const now = new Date();
                const timestamp = `${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                
                const exportData = {
                    timestamp: now.toISOString(),
                    settings: {
                        zoom: state.zoom,
                        pan: state.pan,
                        theme: document.documentElement.classList.contains('dark') ? 'dark' : 'light'
                    },
                    nodes: state.nodes,
                    preview: {
                        canvasWidth: canvas.clientWidth,
                        canvasHeight: canvas.clientHeight,
                        nodeCount: state.nodes.length
                    },
                    metadata: {
                        nextNodeId: state.nextNodeId,
                        selectedNodeId: state.selectedNodeId,
                        version: '1.0'
                    }
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap-${timestamp}.rxt`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const toggleTheme = () => {
                document.documentElement.classList.toggle('dark');
                const isDark = document.documentElement.classList.contains('dark');
                dom.themeIconLight.classList.toggle('hidden', isDark);
                dom.themeIconDark.classList.toggle('hidden', !isDark);
                localStorage.setItem('mindmap-theme', isDark ? 'dark' : 'light');
                requestRedraw();
            };

            const toggleMarkdown = () => {
                state.markdownMode = !state.markdownMode;
                dom.markdownIconOff.classList.toggle('hidden', state.markdownMode);
                dom.markdownIconOn.classList.toggle('hidden', !state.markdownMode);
                localStorage.setItem('mindmap-markdown', state.markdownMode ? 'on' : 'off');
                requestRedraw();
            };

            const renderMarkdownText = (ctx, text, x, y) => {
                const parts = parseMarkdown(text);
                let currentX = x;
                let currentY = y + FONT_SIZE;
                const lineHeight = FONT_SIZE * 1.4;
                
                parts.forEach(part => {
                    const lines = part.text.split('\n');
                    
                    lines.forEach((line, lineIndex) => {
                        if (lineIndex > 0) {
                            currentY += lineHeight;
                            currentX = x;
                        }
                        
                        if (line) {
                            ctx.save();
                            ctx.fillStyle = getCssVar('--node-text');
                            
                            if (part.bold) ctx.font = `700 ${FONT_SIZE}px Inter`;
                            else if (part.italic) ctx.font = `italic 500 ${FONT_SIZE}px Inter`;
                            else ctx.font = `500 ${FONT_SIZE}px Inter`;
                            
                            if (part.code) {
                                ctx.fillStyle = getCssVar('--accent');
                                ctx.fillRect(currentX - 2, currentY - FONT_SIZE + 2, ctx.measureText(line).width + 4, FONT_SIZE + 4);
                                ctx.fillStyle = getCssVar('--bg');
                            }
                            
                            ctx.fillText(line, currentX, currentY);
                            
                            if (part.strikethrough) {
                                const width = ctx.measureText(line).width;
                                ctx.strokeStyle = getCssVar('--node-text');
                                ctx.beginPath();
                                ctx.moveTo(currentX, currentY - FONT_SIZE/4);
                                ctx.lineTo(currentX + width, currentY - FONT_SIZE/4);
                                ctx.stroke();
                            }
                            
                            currentX += ctx.measureText(line).width;
                            ctx.restore();
                        }
                    });
                });
            };

            const measureMarkdownText = (ctx, text) => {
                const parts = parseMarkdown(text);
                let maxWidth = 0;
                let totalHeight = 0;
                let currentLineWidth = 0;
                const lineHeight = FONT_SIZE * 1.4;
                
                parts.forEach(part => {
                    const lines = part.text.split('\n');
                    
                    lines.forEach((line, lineIndex) => {
                        if (lineIndex > 0) {
                            maxWidth = Math.max(maxWidth, currentLineWidth);
                            currentLineWidth = 0;
                            totalHeight += lineHeight;
                        }
                        
                        if (line) {
                            ctx.save();
                            if (part.bold) ctx.font = `700 ${FONT_SIZE}px Inter`;
                            else if (part.italic) ctx.font = `italic 500 ${FONT_SIZE}px Inter`;
                            else ctx.font = `500 ${FONT_SIZE}px Inter`;
                            
                            currentLineWidth += ctx.measureText(line).width;
                            ctx.restore();
                        }
                    });
                });
                
                maxWidth = Math.max(maxWidth, currentLineWidth, 80);
                totalHeight = totalHeight || lineHeight;
                
                return { width: maxWidth, height: totalHeight };
            };

            const parseMarkdown = (text) => {
                const parts = [];
                let current = '';
                let i = 0;
                
                while (i < text.length) {
                    if (text.substr(i, 2) === '**') {
                        if (current) parts.push({ text: current, bold: false, italic: false, code: false, strikethrough: false });
                        current = '';
                        i += 2;
                        while (i < text.length && text.substr(i, 2) !== '**') {
                            current += text[i];
                            i++;
                        }
                        if (current) parts.push({ text: current, bold: true, italic: false, code: false, strikethrough: false });
                        current = '';
                        i += 2;
                    } else if (text[i] === '*' && text[i-1] !== '*' && text[i+1] !== '*') {
                        if (current) parts.push({ text: current, bold: false, italic: false, code: false, strikethrough: false });
                        current = '';
                        i++;
                        while (i < text.length && text[i] !== '*') {
                            current += text[i];
                            i++;
                        }
                        if (current) parts.push({ text: current, bold: false, italic: true, code: false, strikethrough: false });
                        current = '';
                        i++;
                    } else if (text[i] === '`') {
                        if (current) parts.push({ text: current, bold: false, italic: false, code: false, strikethrough: false });
                        current = '';
                        i++;
                        while (i < text.length && text[i] !== '`') {
                            current += text[i];
                            i++;
                        }
                        if (current) parts.push({ text: current, bold: false, italic: false, code: true, strikethrough: false });
                        current = '';
                        i++;
                    } else if (text.substr(i, 2) === '~~') {
                        if (current) parts.push({ text: current, bold: false, italic: false, code: false, strikethrough: false });
                        current = '';
                        i += 2;
                        while (i < text.length && text.substr(i, 2) !== '~~') {
                            current += text[i];
                            i++;
                        }
                        if (current) parts.push({ text: current, bold: false, italic: false, code: false, strikethrough: true });
                        current = '';
                        i += 2;
                    } else {
                        current += text[i];
                        i++;
                    }
                }
                
                if (current) parts.push({ text: current, bold: false, italic: false, code: false, strikethrough: false });
                return parts.length ? parts : [{ text: text, bold: false, italic: false, code: false, strikethrough: false }];
            };

            // --- Actions ---
            const zoom = (factor, pivot = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 }) => {
                const newZoom = Math.max(0.1, Math.min(5, state.zoom * factor));
                const worldPos = screenToWorld(pivot.x, pivot.y);
                
                state.pan.x = pivot.x - worldPos.x * newZoom;
                state.pan.y = pivot.y - worldPos.y * newZoom;
                state.zoom = newZoom;
                
                dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                requestRedraw();
            };

            const fitView = () => {
                if (state.nodes.length === 0) return;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                state.nodes.forEach(n => {
                    minX = Math.min(minX, n.x);
                    minY = Math.min(minY, n.y);
                    maxX = Math.max(maxX, n.x + n.width);
                    maxY = Math.max(maxY, n.y + n.height);
                });

                const padding = 50;
                const contentWidth = maxX - minX;
                const contentHeight = maxY - minY;
                
                const scaleX = (canvas.clientWidth - padding * 2) / contentWidth;
                const scaleY = (canvas.clientHeight - padding * 2) / contentHeight;
                state.zoom = Math.min(scaleX, scaleY, 1);

                const centerX = minX + contentWidth / 2;
                const centerY = minY + contentHeight / 2;

                state.pan.x = canvas.clientWidth / 2 - centerX * state.zoom;
                state.pan.y = canvas.clientHeight / 2 - centerY * state.zoom;
                
                dom.zoomIndicator.textContent = `${Math.round(state.zoom * 100)}%`;
                requestRedraw();
            };



            // --- Helpers ---
            const getMousePos = (e) => ({ x: e.clientX, y: e.clientY - dom.addNodeBtn.closest('header').offsetHeight });
            const screenToWorld = (x, y) => ({ x: (x - state.pan.x) / state.zoom, y: (y - state.pan.y) / state.zoom });
            const worldToScreen = (x, y) => ({ x: x * state.zoom + state.pan.x, y: y * state.zoom + state.pan.y });
            const findNodeById = (id) => state.nodes.find(n => n.id === id);
            const findNodeAt = (x, y) => {
                const worldPos = screenToWorld(x, y);
                return state.nodes.slice().reverse().find(n => 
                    worldPos.x >= n.x && worldPos.x <= n.x + n.width &&
                    worldPos.y >= n.y && worldPos.y <= n.y + n.height
                )?.id || null;
            };
            const getCssVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            
            const fillRoundedRect = (c, x, y, w, h, r) => {
                c.beginPath(); c.moveTo(x+r, y); c.arcTo(x+w, y, x+w, y+h, r); c.arcTo(x+w, y+h, x, y+h, r); c.arcTo(x, y+h, x, y, r); c.arcTo(x, y, x+w, y, r); c.closePath(); c.fill();
            };
            const strokeRoundedRect = (c, x, y, w, h, r) => {
                c.beginPath(); c.moveTo(x+r, y); c.arcTo(x+w, y, x+w, y+h, r); c.arcTo(x+w, y+h, x, y+h, r); c.arcTo(x, y+h, x, y, r); c.arcTo(x, y, x+w, y, r); c.closePath(); c.stroke();
            };

            // --- Initialization ---
            const init = () => {
                const savedTheme = localStorage.getItem('mindmap-theme');
                if (savedTheme === 'light') {
                    document.documentElement.classList.remove('dark');
                }
                toggleTheme(); // Set icons correctly
                toggleTheme();

                const savedMarkdown = localStorage.getItem('mindmap-markdown');
                if (savedMarkdown === 'on') {
                    state.markdownMode = true;
                    dom.markdownIconOff.classList.add('hidden');
                    dom.markdownIconOn.classList.remove('hidden');
                }

                setupEventListeners();
                resizeCanvas();
                
                // Create a welcome map
                const cX = canvas.clientWidth / 2;
                const cY = canvas.clientHeight / 2;
                createNode(screenToWorld(cX, cY).x - 50, screenToWorld(cX, cY).y - 25, 'Welcome!');
                
                saveState();
                fitView();
            };

            init();
        });
    </script>
</body>
</html>
