<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }

        /* Custom dotted background for the canvas */
        .dot-background {
            background-color: #f5f5f5;
            background-image: radial-gradient(#000000 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #mindMapCanvas {
            cursor: grab;
        }

        #mindMapCanvas:active {
            cursor: grabbing;
        }

        /* Styles for the custom context menu */
        #context-menu {
            position: absolute;
            z-index: 1000;
            display: none;
            background-color: #fff;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            padding: 0.5rem;
            min-width: 150px;
        }

        #context-menu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #context-menu li {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #4a5568; /* text-gray-700 */
            transition: background-color 0.2s;
            border-radius: 0.5rem; /* rounded-lg */
        }

        #context-menu li:hover {
            background-color: #f7fafc; /* bg-gray-50 */
        }

        #context-menu li.disabled {
            color: #cbd5e0; /* text-gray-400 */
            cursor: not-allowed;
        }

        /* In-line text input for renaming */
        #inline-rename-input {
            position: absolute;
            z-index: 500;
            display: none;
            background: #fff;
            border: 2px solid #4c51bf; /* indigo-600 */
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
            font: 16px 'Inter', sans-serif;
            color: #1f2937;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <!-- Top Header -->
    <header class="bg-white p-4 shadow-md flex justify-between items-center z-10">
        <h1 class="text-2xl font-bold text-gray-800">Mind Map Designer</h1>
        <div class="flex items-center space-x-4">
            <label for="curvedLinesToggle" class="flex items-center cursor-pointer">
                <span class="text-gray-700 mr-2">Use Curved Lines</span>
                <input type="checkbox" id="curvedLinesToggle" class="sr-only peer" checked>
                <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-indigo-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
            </label>
            <button id="resetPositionBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200">
                Reset Position
            </button>
            <button id="createNodeBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors duration-200">
                Create Node
            </button>
        </div>
    </header>

    <!-- Canvas Container -->
    <main class="flex-1 dot-background">
        <canvas id="mindMapCanvas" class="w-full h-full"></canvas>
    </main>
    
    <!-- Inline text input for renaming -->
    <input type="text" id="inline-rename-input">

    <!-- Custom Right-Click Menu -->
    <div id="context-menu" class="hidden">
        <ul>
            <li id="menu-create">Create New Node</li>
            <li id="menu-add-branch" class="disabled">Add Branch</li>
            <li id="menu-rename" class="disabled">Rename Node</li>
            <li id="menu-delete" class="disabled">Delete Element</li>
            <li id="menu-delete-connection" class="disabled">Delete Connection</li>
        </ul>
    </div>

    <script>
        window.onload = function() {
            // Get references to all DOM elements
            const canvas = document.getElementById('mindMapCanvas');
            const ctx = canvas.getContext('2d');
            const createNodeBtn = document.getElementById('createNodeBtn');
            const resetPositionBtn = document.getElementById('resetPositionBtn');
            const curvedLinesToggle = document.getElementById('curvedLinesToggle');
            const contextMenu = document.getElementById('context-menu');
            const menuCreateBtn = document.getElementById('menu-create');
            const menuAddBranchBtn = document.getElementById('menu-add-branch');
            const menuRenameBtn = document.getElementById('menu-rename');
            const menuDeleteBtn = document.getElementById('menu-delete');
            const menuDeleteConnectionBtn = document.getElementById('menu-delete-connection');
            const inlineRenameInput = document.getElementById('inline-rename-input');

            // --- State Management ---
            let nodes = [];
            let selectedNodeId = null;
            let draggedNodeId = null;
            let lastMouseX, lastMouseY;
            let nextNodeId = 1;
            let zoomScale = 1;
            let panX = 0, panY = 0;
            let editingNodeId = null;
            let textSelected = false;
            let multiSelectedNodes = [];
            let selectedConnectionId = null;

            // --- Canvas and Drawing Logic ---

            // Function to resize canvas to fill the window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - document.querySelector('header').offsetHeight;
                draw();
            }

            // Function to draw the entire mind map
            function draw() {
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update background dot size based on zoom
                const dotSize = 20 * zoomScale;
                canvas.parentElement.style.backgroundSize = `${dotSize}px ${dotSize}px`;
                canvas.parentElement.style.backgroundPosition = `${panX % dotSize}px ${panY % dotSize}px`;
                
                // Apply zoom and pan transformation
                ctx.save();
                ctx.translate(panX, panY);
                ctx.scale(zoomScale, zoomScale);

                // Draw branches (lines) first
                // Ensure consistent font before measuring/drawing text
                ctx.font = '16px "Inter", sans-serif';

                for (const node of nodes) {
                    if (node.parent !== null) {
                        const parentNode = nodes.find(n => n.id === node.parent);
                        if (parentNode) {
                            // Calculate the start and end points at the center of the nodes
                            const startX = parentNode.x + parentNode.width / 2;
                            const startY = parentNode.y + parentNode.height / 2;
                            const endX = node.x + node.width / 2;
                            const endY = node.y + node.height / 2;

                            ctx.beginPath();
                            ctx.moveTo(startX, startY);

                            if (curvedLinesToggle.checked) {
                                // Calculate a dynamic control offset for a smoother S-curve
                                // Increased the multiplier from 0.3 to 0.6 for a more pronounced curve.
                                const dx = endX - startX;
                                const dy = endY - startY;
                                const controlOffset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.6;

                                // Draw a gentle S-curve using a cubic BÃ©zier curve
                                // The control points create a smooth "bend" in the line.
                                ctx.bezierCurveTo(
                                    startX + controlOffset, startY,
                                    endX - controlOffset, endY,
                                    endX, endY
                                );
                            } else {
                                // Draw a straight line
                                ctx.lineTo(endX, endY);
                            }

                            ctx.lineWidth = 2;
                            ctx.strokeStyle = '#374151'; // gray-700
                            ctx.stroke();
                        }
                    }
                }

                // Draw nodes
                for (const node of nodes) {
                    // Node styles
                    const isSelected = (node.id === selectedNodeId);
                    const isMultiSelected = multiSelectedNodes.includes(node.id);
                    const isDragged = (node.id === draggedNodeId);
                    ctx.fillStyle = '#cbd5e0'; // gray-300
                    ctx.strokeStyle = isSelected ? '#4c51bf' : (isMultiSelected ? '#10b981' : (isDragged ? '#a3a6ff' : '#6b7280')); // indigo-600, green-500, or indigo-300
                    ctx.lineWidth = isSelected ? 4 : (isMultiSelected ? 3 : (isDragged ? 3 : 2));
                    
                    // Draw node rectangle
                    const padding = 15;
                    // Measure text to determine node width (font set above)
                    const textWidth = ctx.measureText(node.text).width;
                    const rectWidth = textWidth + padding * 2;
                    const rectHeight = 40;
                    
                    // Draw a rounded rectangle for the node
                    ctx.beginPath();
                    const radius = 10;
                    ctx.moveTo(node.x + radius, node.y);
                    ctx.lineTo(node.x + rectWidth - radius, node.y);
                    ctx.arc(node.x + rectWidth - radius, node.y + radius, radius, Math.PI * 1.5, Math.PI * 2);
                    ctx.lineTo(node.x + rectWidth, node.y + rectHeight - radius);
                    ctx.arc(node.x + rectWidth - radius, node.y + rectHeight - radius, radius, 0, Math.PI * 0.5);
                    ctx.lineTo(node.x + radius, node.y + rectHeight);
                    ctx.arc(node.x + radius, node.y + rectHeight - radius, radius, Math.PI * 0.5, Math.PI);
                    ctx.lineTo(node.x, node.y + radius);
                    ctx.arc(node.x + radius, node.y + radius, radius, Math.PI, Math.PI * 1.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw text inside the node
                    ctx.fillStyle = '#1f2937'; // gray-900
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Show cursor for editing node
                    if (node.id === editingNodeId) {
                        if (textSelected) {
                            // Draw pink selection background
                            ctx.fillStyle = '#ffc0cb'; // pink
                            ctx.fillRect(node.x + 5, node.y + 5, rectWidth - 10, rectHeight - 10);
                            ctx.fillStyle = '#1f2937'; // reset text color
                        }
                        const displayText = node.text + (textSelected ? '' : '|');
                        ctx.fillText(displayText, node.x + rectWidth / 2, node.y + rectHeight / 2);
                    } else {
                        ctx.fillText(node.text, node.x + rectWidth / 2, node.y + rectHeight / 2);
                    }
                    
                    // Update node dimensions for hit testing
                    node.width = rectWidth;
                    node.height = rectHeight;
                }
                
                // Restore transformation
                ctx.restore();
            }

            // Hit test to see if a click is inside a node
            function isInsideNode(x, y) {
                // Adjust coordinates for zoom and pan
                const adjustedX = (x - panX) / zoomScale;
                const adjustedY = (y - panY) / zoomScale;
                
                for (const node of nodes) {
                    // Hit test logic to check if a point (x, y) is inside the node's bounds
                    if (adjustedX > node.x && adjustedX < node.x + node.width &&
                        adjustedY > node.y && adjustedY < node.y + node.height) {
                        return node.id;
                    }
                }
                return null;
            }

            // Hit test to see if a click is on a connection line
            function isOnConnection(x, y) {
                // Convert screen coords to canvas (world) coords
                const adjustedX = (x - panX) / zoomScale;
                const adjustedY = (y - panY) / zoomScale;
                // Keep hit tolerance roughly constant in screen space
                const tolerance = 8 / zoomScale;
                const segDist = (px, py, x1, y1, x2, y2) => {
                    const A = px - x1;
                    const B = py - y1;
                    const C = x2 - x1;
                    const D = y2 - y1;
                    const dot = A * C + B * D;
                    const lenSq = C * C + D * D;
                    let t = lenSq !== 0 ? dot / lenSq : -1;
                    t = Math.max(0, Math.min(1, t));
                    const xx = x1 + t * C;
                    const yy = y1 + t * D;
                    const dx = px - xx;
                    const dy = py - yy;
                    return Math.hypot(dx, dy);
                };
                
                for (const node of nodes) {
                    if (node.parent !== null) {
                        const parentNode = nodes.find(n => n.id === node.parent);
                        if (parentNode) {
                            const startX = parentNode.x + parentNode.width / 2;
                            const startY = parentNode.y + parentNode.height / 2;
                            const endX = node.x + node.width / 2;
                            const endY = node.y + node.height / 2;
                            if (curvedLinesToggle.checked) {
                                // Approximate the cubic Bezier curve with small segments and test distance
                                const dx = endX - startX;
                                const dy = endY - startY;
                                const controlOffset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.6;
                                const c1x = startX + controlOffset;
                                const c1y = startY;
                                const c2x = endX - controlOffset;
                                const c2y = endY;
                                const steps = 20;
                                let prevX = startX;
                                let prevY = startY;
                                for (let i = 1; i <= steps; i++) {
                                    const t = i / steps;
                                    // Cubic Bezier formula
                                    const mt = 1 - t;
                                    const bx = mt*mt*mt*startX + 3*mt*mt*t*c1x + 3*mt*t*t*c2x + t*t*t*endX;
                                    const by = mt*mt*mt*startY + 3*mt*mt*t*c1y + 3*mt*t*t*c2y + t*t*t*endY;
                                    if (segDist(adjustedX, adjustedY, prevX, prevY, bx, by) <= tolerance) {
                                        return { parentId: node.parent, childId: node.id };
                                    }
                                    prevX = bx;
                                    prevY = by;
                                }
                            } else {
                                if (segDist(adjustedX, adjustedY, startX, startY, endX, endY) <= tolerance) {
                                    return { parentId: node.parent, childId: node.id };
                                }
                            }
                        }
                    }
                }
                return null;
            }

            // Clean up connection inconsistencies
            function cleanupConnections() {
                // Remove duplicate children and fix parent-child mismatches
                for (const node of nodes) {
                    // Remove duplicate children
                    node.children = [...new Set(node.children)];
                    
                    // Ensure all children exist and have this node as parent
                    node.children = node.children.filter(childId => {
                        const child = nodes.find(n => n.id === childId);
                        if (!child) return false; // Child node doesn't exist
                        if (child.parent !== node.id) {
                            // Fix the parent reference
                            child.parent = node.id;
                        }
                        return true;
                    });
                    
                    // If node has a parent, ensure parent exists and has this node as child
                    if (node.parent !== null) {
                        const parent = nodes.find(n => n.id === node.parent);
                        if (parent) {
                            if (!parent.children.includes(node.id)) {
                                parent.children.push(node.id);
                            }
                        } else {
                            // Parent doesn't exist, remove the reference
                            node.parent = null;
                        }
                    }
                }
            }

            // --- Node Operations ---

            // Creates a new node and adds it to the mind map
            function createNode(x, y, text = 'New Node', parentId = null) {
                // Calculate initial dimensions
                ctx.font = '16px "Inter", sans-serif';
                const textWidth = ctx.measureText(text).width;
                const padding = 15;
                
                const newNode = {
                    id: nextNodeId++,
                    text: text,
                    x: x,
                    y: y,
                    parent: parentId,
                    children: [],
                    width: textWidth + padding * 2,
                    height: 40
                };
                nodes.push(newNode);

                if (parentId !== null) {
                    const parentNode = nodes.find(n => n.id === parentId);
                    if (parentNode) {
                        parentNode.children.push(newNode.id);
                    }
                }
                draw();
            }

            // Deletes a node and all its children
            function deleteNode(nodeId) {
                const nodeToDelete = nodes.find(n => n.id === nodeId);
                if (!nodeToDelete) return;

                const nodesToDelete = [nodeId];
                let queue = [...nodeToDelete.children];

                while (queue.length > 0) {
                    const childId = queue.shift();
                    nodesToDelete.push(childId);
                    const childNode = nodes.find(n => n.id === childId);
                    if (childNode) {
                        queue = queue.concat(childNode.children);
                    }
                }

                // Filter out all nodes to be deleted
                nodes = nodes.filter(n => !nodesToDelete.includes(n.id));

                // Remove from parent's children array
                if (nodeToDelete.parent !== null) {
                    const parentNode = nodes.find(n => n.id === nodeToDelete.parent);
                    if (parentNode) {
                        parentNode.children = parentNode.children.filter(childId => childId !== nodeId);
                    }
                }

                draw();
            }

            // Deletes a connection between two nodes
            function deleteConnection(parentId, childId) {
                const parentNode = nodes.find(n => n.id === parentId);
                const childNode = nodes.find(n => n.id === childId);
                
                if (parentNode && childNode) {
                    // Remove child from parent's children array
                    parentNode.children = parentNode.children.filter(id => id !== childId);
                    // Remove parent reference from child
                    childNode.parent = null;
                    draw();
                }
            }

            // Renames a node
            function renameNode(nodeId, newText) {
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                    node.text = newText;
                    draw();
                }
            }
            
            // --- Event Listeners ---
            
            // Note: Right-click context menu is handled on the canvas element below; do not block it globally
            
            // Initialize the canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Reset position to focus on first node
            resetPositionBtn.addEventListener('click', () => {
                if (nodes.length > 0) {
                    const firstNode = nodes[0];
                    panX = canvas.width / 2 - (firstNode.x + firstNode.width / 2) * zoomScale;
                    panY = canvas.height / 2 - (firstNode.y + firstNode.height / 2) * zoomScale;
                    draw();
                }
            });

            // Create initial node when the button is clicked
            createNodeBtn.addEventListener('click', () => {
                // Place the first node in the center of the canvas
                if (nodes.length === 0) {
                    createNode(canvas.width / 2 - 50, canvas.height / 2 - 20, "Main Idea");
                } else {
                    // For subsequent nodes, create them near the top-left
                    createNode(50, 50);
                }
            });

            // Handle scroll wheel for zooming
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.1, Math.min(3, zoomScale * zoomFactor));
                
                // Adjust pan to zoom towards mouse position
                panX = mouseX - (mouseX - panX) * (newZoom / zoomScale);
                panY = mouseY - (mouseY - panY) * (newZoom / zoomScale);
                
                zoomScale = newZoom;
                draw();
            });

            // Handle mouse down event on canvas for dragging
            canvas.addEventListener('mousedown', (e) => {
                // Only allow left-click dragging
                if (e.button !== 0) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const clickedNodeId = isInsideNode(mouseX, mouseY);
                
                // Auto-save if clicking away from editing node
                if (editingNodeId !== null && clickedNodeId !== editingNodeId) {
                    editingNodeId = null;
                    textSelected = false;
                }
                
                // Handle Ctrl/Meta + click for multi-selection
                if ((e.ctrlKey || e.metaKey) && clickedNodeId !== null) {
                    // If there's a selectedNodeId that's not in multiSelectedNodes, add it first
                    if (selectedNodeId !== null && !multiSelectedNodes.includes(selectedNodeId)) {
                        multiSelectedNodes.push(selectedNodeId);
                    }
                    
                    if (multiSelectedNodes.includes(clickedNodeId)) {
                        // Remove from selection
                        multiSelectedNodes = multiSelectedNodes.filter(id => id !== clickedNodeId);
                    } else {
                        // Add to selection
                        multiSelectedNodes.push(clickedNodeId);
                    }
                    selectedNodeId = clickedNodeId;
                    draw();
                    return; // Don't start dragging when Ctrl+clicking
                }
                
                // Set selected node on single click, clear if clicking empty space
                if (clickedNodeId !== null) {
                    selectedNodeId = clickedNodeId;
                    multiSelectedNodes = []; // Clear multi-selection on normal click
                } else {
                    selectedNodeId = null;
                    multiSelectedNodes = [];
                }
                
                draggedNodeId = clickedNodeId;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                contextMenu.style.display = 'none'; // Hide menu on drag start
                canvas.style.cursor = 'grabbing';
                draw();
            });

            // Handle mouse move event for dragging and cursor updates
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Update cursor based on hover state when not dragging
                if (lastMouseX === undefined) {
                    const hoveredNodeId = isInsideNode(mouseX, mouseY);
                    canvas.style.cursor = hoveredNodeId !== null ? 'default' : 'grab';
                }
                
                if (lastMouseX !== undefined && lastMouseY !== undefined) {
                    if (draggedNodeId !== null) {
                        // Move the selected node
                        const nodeToDrag = nodes.find(n => n.id === draggedNodeId);
                        if (nodeToDrag) {
                            nodeToDrag.x += (mouseX - lastMouseX) / zoomScale;
                            nodeToDrag.y += (mouseY - lastMouseY) / zoomScale;
                        }
                    } else {
                        // Pan the canvas
                        panX += mouseX - lastMouseX;
                        panY += mouseY - lastMouseY;
                    }
                    
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                    draw();
                }
            });

            // Handle mouse up event to stop dragging
            canvas.addEventListener('mouseup', () => {
                draggedNodeId = null;
                lastMouseX = undefined;
                lastMouseY = undefined;
                canvas.style.cursor = 'grab';
            });
            
            // Handle double-click for inline renaming
            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const nodeId = isInsideNode(mouseX, mouseY);
                if (nodeId !== null) {
                    editingNodeId = nodeId;
                    selectedNodeId = nodeId;
                    textSelected = false;
                    draw();
                }
            });

            // Handle keyboard input for editing and connections
            window.addEventListener('keydown', (e) => {
                // Handle Enter for connecting nodes
                if (e.key === 'Enter' && editingNodeId === null && multiSelectedNodes.length > 1) {
                        e.preventDefault();
                        // Connect all nodes in sequence
                        for (let i = 0; i < multiSelectedNodes.length - 1; i++) {
                            const parentNode = nodes.find(n => n.id === multiSelectedNodes[i]);
                            const childNode = nodes.find(n => n.id === multiSelectedNodes[i + 1]);
                            
                            if (parentNode && childNode) {
                                // Only connect if not already connected
                                const isConnectedForward = childNode.parent === parentNode.id;
                                const isConnectedReverse = parentNode.parent === childNode.id;
                                
                                if (!isConnectedForward && !isConnectedReverse) {
                                    // Only connect if child doesn't already have a parent
                                    if (childNode.parent === null) {
                                        childNode.parent = parentNode.id;
                                        if (!parentNode.children.includes(childNode.id)) {
                                            parentNode.children.push(childNode.id);
                                        }
                                    }
                                }
                            }
                        }
                        multiSelectedNodes = [];
                        cleanupConnections();
                        draw();
                        return;
                }
                
                if (editingNodeId !== null) {
                    e.preventDefault(); // Prevent default browser behavior when editing
                    const editingNode = nodes.find(n => n.id === editingNodeId);
                    if (editingNode) {
                        if (e.key === 'Enter' || e.key === 'Escape') {
                            editingNodeId = null;
                            textSelected = false;
                            draw();
                        } else if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                            textSelected = true;
                            draw();
                        } else if (e.key === 'Backspace') {
                            if (textSelected) {
                                editingNode.text = '';
                                textSelected = false;
                            } else {
                                editingNode.text = editingNode.text.slice(0, -1);
                            }
                            draw();
                        } else if (e.key.length === 1 && !e.ctrlKey) {
                            if (textSelected) {
                                editingNode.text = e.key;
                                textSelected = false;
                            } else {
                                editingNode.text += e.key;
                            }
                            draw();
                        }
                    }
                }
            });

            // Handle right-click context menu
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                selectedNodeId = isInsideNode(mouseX, mouseY);
                selectedConnectionId = isOnConnection(mouseX, mouseY);

                // Position the menu
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.display = 'block';

                // Enable/disable menu options based on selection
                if (selectedNodeId !== null) {
                    menuAddBranchBtn.classList.remove('disabled');
                    menuRenameBtn.classList.remove('disabled');
                    menuDeleteBtn.classList.remove('disabled');
                    menuDeleteConnectionBtn.classList.add('disabled');
                } else if (selectedConnectionId !== null) {
                    menuAddBranchBtn.classList.add('disabled');
                    menuRenameBtn.classList.add('disabled');
                    menuDeleteBtn.classList.add('disabled');
                    menuDeleteConnectionBtn.classList.remove('disabled');
                } else {
                    menuAddBranchBtn.classList.add('disabled');
                    menuRenameBtn.classList.add('disabled');
                    menuDeleteBtn.classList.add('disabled');
                    menuDeleteConnectionBtn.classList.add('disabled');
                }
            });

            // Hide the menu on any click outside the menu
            window.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.style.display = 'none';
                    // Do not force-exit editing on generic clicks; canvas handlers manage that
                }
            });


            
            // Toggle for curved/straight lines
            curvedLinesToggle.addEventListener('change', () => {
                draw();
            });

            // --- Context Menu Actions ---

            menuCreateBtn.addEventListener('click', () => {
                if (contextMenu.style.display === 'block') {
                    const rect = canvas.getBoundingClientRect();
                    const menuX = (parseInt(contextMenu.style.left) - rect.left - panX) / zoomScale;
                    const menuY = (parseInt(contextMenu.style.top) - rect.top - panY) / zoomScale;
                    createNode(menuX, menuY);
                    contextMenu.style.display = 'none';
                }
            });

            menuAddBranchBtn.addEventListener('click', () => {
                if (selectedNodeId !== null && contextMenu.style.display === 'block') {
                    const selectedNode = nodes.find(n => n.id === selectedNodeId);
                    if (selectedNode) {
                        createNode(selectedNode.x + 150, selectedNode.y, 'New Branch', selectedNode.id);
                    }
                    contextMenu.style.display = 'none';
                }
            });

            menuDeleteBtn.addEventListener('click', () => {
                if (selectedNodeId !== null && contextMenu.style.display === 'block') {
                    deleteNode(selectedNodeId);
                    selectedNodeId = null;
                    contextMenu.style.display = 'none';
                }
            });

            menuRenameBtn.addEventListener('click', () => {
                if (selectedNodeId !== null && contextMenu.style.display === 'block') {
                    editingNodeId = selectedNodeId;
                    textSelected = false;
                    contextMenu.style.display = 'none';
                    draw();
                }
            });

            menuDeleteConnectionBtn.addEventListener('click', () => {
                if (selectedConnectionId !== null && contextMenu.style.display === 'block') {
                    deleteConnection(selectedConnectionId.parentId, selectedConnectionId.childId);
                    selectedConnectionId = null;
                    contextMenu.style.display = 'none';
                }
            });
        };
    </script>
</body>
</html>
